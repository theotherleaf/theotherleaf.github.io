/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-node_modules_react-animated-cursor_dist_index_umd_js"],{

/***/ "./node_modules/react-animated-cursor/dist/index.umd.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-animated-cursor/dist/index.umd.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? module.exports = factory(__webpack_require__(/*! react */ \"./node_modules/react/index.js\")) :\n  0;\n})(this, (function (React) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\n  var propTypes = {exports: {}};\n\n  var reactIs = {exports: {}};\n\n  var reactIs_production_min = {};\n\n  /** @license React v16.13.1\n   * react-is.production.min.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var hasRequiredReactIs_production_min;\n\n  function requireReactIs_production_min () {\n  \tif (hasRequiredReactIs_production_min) return reactIs_production_min;\n  \thasRequiredReactIs_production_min = 1;\n  var b=\"function\"===typeof Symbol&&Symbol.for,c=b?Symbol.for(\"react.element\"):60103,d=b?Symbol.for(\"react.portal\"):60106,e=b?Symbol.for(\"react.fragment\"):60107,f=b?Symbol.for(\"react.strict_mode\"):60108,g=b?Symbol.for(\"react.profiler\"):60114,h=b?Symbol.for(\"react.provider\"):60109,k=b?Symbol.for(\"react.context\"):60110,l=b?Symbol.for(\"react.async_mode\"):60111,m=b?Symbol.for(\"react.concurrent_mode\"):60111,n=b?Symbol.for(\"react.forward_ref\"):60112,p=b?Symbol.for(\"react.suspense\"):60113,q=b?\n  \tSymbol.for(\"react.suspense_list\"):60120,r=b?Symbol.for(\"react.memo\"):60115,t=b?Symbol.for(\"react.lazy\"):60116,v=b?Symbol.for(\"react.block\"):60121,w=b?Symbol.for(\"react.fundamental\"):60117,x=b?Symbol.for(\"react.responder\"):60118,y=b?Symbol.for(\"react.scope\"):60119;\n  \tfunction z(a){if(\"object\"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m;reactIs_production_min.ContextConsumer=k;reactIs_production_min.ContextProvider=h;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d;\n  \treactIs_production_min.Profiler=g;reactIs_production_min.StrictMode=f;reactIs_production_min.Suspense=p;reactIs_production_min.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min.isConcurrentMode=A;reactIs_production_min.isContextConsumer=function(a){return z(a)===k};reactIs_production_min.isContextProvider=function(a){return z(a)===h};reactIs_production_min.isElement=function(a){return \"object\"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z(a)===n};reactIs_production_min.isFragment=function(a){return z(a)===e};reactIs_production_min.isLazy=function(a){return z(a)===t};\n  \treactIs_production_min.isMemo=function(a){return z(a)===r};reactIs_production_min.isPortal=function(a){return z(a)===d};reactIs_production_min.isProfiler=function(a){return z(a)===g};reactIs_production_min.isStrictMode=function(a){return z(a)===f};reactIs_production_min.isSuspense=function(a){return z(a)===p};\n  \treactIs_production_min.isValidElementType=function(a){return \"string\"===typeof a||\"function\"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||\"object\"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min.typeOf=z;\n  \treturn reactIs_production_min;\n  }\n\n  var reactIs_development = {};\n\n  /** @license React v16.13.1\n   * react-is.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var hasRequiredReactIs_development;\n\n  function requireReactIs_development () {\n  \tif (hasRequiredReactIs_development) return reactIs_development;\n  \thasRequiredReactIs_development = 1;\n\n\n\n  \tif (true) {\n  \t  (function() {\n\n  \t// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n  \t// nor polyfill, then a plain number is used for performance.\n  \tvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n  \tvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\n  \tvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\n  \tvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\n  \tvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\n  \tvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\n  \tvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\n  \tvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n  \t// (unstable) APIs that have been removed. Can we remove the symbols?\n\n  \tvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\n  \tvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\n  \tvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\n  \tvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\n  \tvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\n  \tvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\n  \tvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\n  \tvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\n  \tvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\n  \tvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\n  \tvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\n  \tfunction isValidElementType(type) {\n  \t  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  \t  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n  \t}\n\n  \tfunction typeOf(object) {\n  \t  if (typeof object === 'object' && object !== null) {\n  \t    var $$typeof = object.$$typeof;\n\n  \t    switch ($$typeof) {\n  \t      case REACT_ELEMENT_TYPE:\n  \t        var type = object.type;\n\n  \t        switch (type) {\n  \t          case REACT_ASYNC_MODE_TYPE:\n  \t          case REACT_CONCURRENT_MODE_TYPE:\n  \t          case REACT_FRAGMENT_TYPE:\n  \t          case REACT_PROFILER_TYPE:\n  \t          case REACT_STRICT_MODE_TYPE:\n  \t          case REACT_SUSPENSE_TYPE:\n  \t            return type;\n\n  \t          default:\n  \t            var $$typeofType = type && type.$$typeof;\n\n  \t            switch ($$typeofType) {\n  \t              case REACT_CONTEXT_TYPE:\n  \t              case REACT_FORWARD_REF_TYPE:\n  \t              case REACT_LAZY_TYPE:\n  \t              case REACT_MEMO_TYPE:\n  \t              case REACT_PROVIDER_TYPE:\n  \t                return $$typeofType;\n\n  \t              default:\n  \t                return $$typeof;\n  \t            }\n\n  \t        }\n\n  \t      case REACT_PORTAL_TYPE:\n  \t        return $$typeof;\n  \t    }\n  \t  }\n\n  \t  return undefined;\n  \t} // AsyncMode is deprecated along with isAsyncMode\n\n  \tvar AsyncMode = REACT_ASYNC_MODE_TYPE;\n  \tvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n  \tvar ContextConsumer = REACT_CONTEXT_TYPE;\n  \tvar ContextProvider = REACT_PROVIDER_TYPE;\n  \tvar Element = REACT_ELEMENT_TYPE;\n  \tvar ForwardRef = REACT_FORWARD_REF_TYPE;\n  \tvar Fragment = REACT_FRAGMENT_TYPE;\n  \tvar Lazy = REACT_LAZY_TYPE;\n  \tvar Memo = REACT_MEMO_TYPE;\n  \tvar Portal = REACT_PORTAL_TYPE;\n  \tvar Profiler = REACT_PROFILER_TYPE;\n  \tvar StrictMode = REACT_STRICT_MODE_TYPE;\n  \tvar Suspense = REACT_SUSPENSE_TYPE;\n  \tvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\n  \tfunction isAsyncMode(object) {\n  \t  {\n  \t    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n  \t      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n  \t      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n  \t    }\n  \t  }\n\n  \t  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n  \t}\n  \tfunction isConcurrentMode(object) {\n  \t  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n  \t}\n  \tfunction isContextConsumer(object) {\n  \t  return typeOf(object) === REACT_CONTEXT_TYPE;\n  \t}\n  \tfunction isContextProvider(object) {\n  \t  return typeOf(object) === REACT_PROVIDER_TYPE;\n  \t}\n  \tfunction isElement(object) {\n  \t  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  \t}\n  \tfunction isForwardRef(object) {\n  \t  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n  \t}\n  \tfunction isFragment(object) {\n  \t  return typeOf(object) === REACT_FRAGMENT_TYPE;\n  \t}\n  \tfunction isLazy(object) {\n  \t  return typeOf(object) === REACT_LAZY_TYPE;\n  \t}\n  \tfunction isMemo(object) {\n  \t  return typeOf(object) === REACT_MEMO_TYPE;\n  \t}\n  \tfunction isPortal(object) {\n  \t  return typeOf(object) === REACT_PORTAL_TYPE;\n  \t}\n  \tfunction isProfiler(object) {\n  \t  return typeOf(object) === REACT_PROFILER_TYPE;\n  \t}\n  \tfunction isStrictMode(object) {\n  \t  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n  \t}\n  \tfunction isSuspense(object) {\n  \t  return typeOf(object) === REACT_SUSPENSE_TYPE;\n  \t}\n\n  \treactIs_development.AsyncMode = AsyncMode;\n  \treactIs_development.ConcurrentMode = ConcurrentMode;\n  \treactIs_development.ContextConsumer = ContextConsumer;\n  \treactIs_development.ContextProvider = ContextProvider;\n  \treactIs_development.Element = Element;\n  \treactIs_development.ForwardRef = ForwardRef;\n  \treactIs_development.Fragment = Fragment;\n  \treactIs_development.Lazy = Lazy;\n  \treactIs_development.Memo = Memo;\n  \treactIs_development.Portal = Portal;\n  \treactIs_development.Profiler = Profiler;\n  \treactIs_development.StrictMode = StrictMode;\n  \treactIs_development.Suspense = Suspense;\n  \treactIs_development.isAsyncMode = isAsyncMode;\n  \treactIs_development.isConcurrentMode = isConcurrentMode;\n  \treactIs_development.isContextConsumer = isContextConsumer;\n  \treactIs_development.isContextProvider = isContextProvider;\n  \treactIs_development.isElement = isElement;\n  \treactIs_development.isForwardRef = isForwardRef;\n  \treactIs_development.isFragment = isFragment;\n  \treactIs_development.isLazy = isLazy;\n  \treactIs_development.isMemo = isMemo;\n  \treactIs_development.isPortal = isPortal;\n  \treactIs_development.isProfiler = isProfiler;\n  \treactIs_development.isStrictMode = isStrictMode;\n  \treactIs_development.isSuspense = isSuspense;\n  \treactIs_development.isValidElementType = isValidElementType;\n  \treactIs_development.typeOf = typeOf;\n  \t  })();\n  \t}\n  \treturn reactIs_development;\n  }\n\n  var hasRequiredReactIs;\n\n  function requireReactIs () {\n  \tif (hasRequiredReactIs) return reactIs.exports;\n  \thasRequiredReactIs = 1;\n  \t(function (module) {\n\n  \t\tif (false) {} else {\n  \t\t  module.exports = requireReactIs_development();\n  \t\t}\n  } (reactIs));\n  \treturn reactIs.exports;\n  }\n\n  /*\n  object-assign\n  (c) Sindre Sorhus\n  @license MIT\n  */\n\n  var objectAssign;\n  var hasRequiredObjectAssign;\n\n  function requireObjectAssign () {\n  \tif (hasRequiredObjectAssign) return objectAssign;\n  \thasRequiredObjectAssign = 1;\n  \t/* eslint-disable no-unused-vars */\n  \tvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\n  \tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n  \tvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n  \tfunction toObject(val) {\n  \t\tif (val === null || val === undefined) {\n  \t\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n  \t\t}\n\n  \t\treturn Object(val);\n  \t}\n\n  \tfunction shouldUseNative() {\n  \t\ttry {\n  \t\t\tif (!Object.assign) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\t// Detect buggy property enumeration order in older V8 versions.\n\n  \t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n  \t\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n  \t\t\ttest1[5] = 'de';\n  \t\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n  \t\t\tvar test2 = {};\n  \t\t\tfor (var i = 0; i < 10; i++) {\n  \t\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n  \t\t\t}\n  \t\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n  \t\t\t\treturn test2[n];\n  \t\t\t});\n  \t\t\tif (order2.join('') !== '0123456789') {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n  \t\t\tvar test3 = {};\n  \t\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n  \t\t\t\ttest3[letter] = letter;\n  \t\t\t});\n  \t\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n  \t\t\t\t\t'abcdefghijklmnopqrst') {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\treturn true;\n  \t\t} catch (err) {\n  \t\t\t// We don't expect any of the above to throw, but better to be safe.\n  \t\t\treturn false;\n  \t\t}\n  \t}\n\n  \tobjectAssign = shouldUseNative() ? Object.assign : function (target, source) {\n  \t\tvar from;\n  \t\tvar to = toObject(target);\n  \t\tvar symbols;\n\n  \t\tfor (var s = 1; s < arguments.length; s++) {\n  \t\t\tfrom = Object(arguments[s]);\n\n  \t\t\tfor (var key in from) {\n  \t\t\t\tif (hasOwnProperty.call(from, key)) {\n  \t\t\t\t\tto[key] = from[key];\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tif (getOwnPropertySymbols) {\n  \t\t\t\tsymbols = getOwnPropertySymbols(from);\n  \t\t\t\tfor (var i = 0; i < symbols.length; i++) {\n  \t\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n  \t\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\treturn to;\n  \t};\n  \treturn objectAssign;\n  }\n\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var ReactPropTypesSecret_1;\n  var hasRequiredReactPropTypesSecret;\n\n  function requireReactPropTypesSecret () {\n  \tif (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;\n  \thasRequiredReactPropTypesSecret = 1;\n\n  \tvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\n  \tReactPropTypesSecret_1 = ReactPropTypesSecret;\n  \treturn ReactPropTypesSecret_1;\n  }\n\n  var has;\n  var hasRequiredHas;\n\n  function requireHas () {\n  \tif (hasRequiredHas) return has;\n  \thasRequiredHas = 1;\n  \thas = Function.call.bind(Object.prototype.hasOwnProperty);\n  \treturn has;\n  }\n\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var checkPropTypes_1;\n  var hasRequiredCheckPropTypes;\n\n  function requireCheckPropTypes () {\n  \tif (hasRequiredCheckPropTypes) return checkPropTypes_1;\n  \thasRequiredCheckPropTypes = 1;\n\n  \tvar printWarning = function() {};\n\n  \tif (true) {\n  \t  var ReactPropTypesSecret = requireReactPropTypesSecret();\n  \t  var loggedTypeFailures = {};\n  \t  var has = requireHas();\n\n  \t  printWarning = function(text) {\n  \t    var message = 'Warning: ' + text;\n  \t    if (typeof console !== 'undefined') {\n  \t      console.error(message);\n  \t    }\n  \t    try {\n  \t      // --- Welcome to debugging React ---\n  \t      // This error was thrown as a convenience so that you can use this stack\n  \t      // to find the callsite that caused this warning to fire.\n  \t      throw new Error(message);\n  \t    } catch (x) { /**/ }\n  \t  };\n  \t}\n\n  \t/**\n  \t * Assert that the values match with the type specs.\n  \t * Error messages are memorized and will only be shown once.\n  \t *\n  \t * @param {object} typeSpecs Map of name to a ReactPropType\n  \t * @param {object} values Runtime values that need to be type-checked\n  \t * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n  \t * @param {string} componentName Name of the component for error messages.\n  \t * @param {?Function} getStack Returns the component stack.\n  \t * @private\n  \t */\n  \tfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  \t  if (true) {\n  \t    for (var typeSpecName in typeSpecs) {\n  \t      if (has(typeSpecs, typeSpecName)) {\n  \t        var error;\n  \t        // Prop type validation may throw. In case they do, we don't want to\n  \t        // fail the render phase where it didn't fail before. So we log it.\n  \t        // After these have been cleaned up, we'll let them throw.\n  \t        try {\n  \t          // This is intentionally an invariant that gets caught. It's the same\n  \t          // behavior as without this statement except with a better message.\n  \t          if (typeof typeSpecs[typeSpecName] !== 'function') {\n  \t            var err = Error(\n  \t              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n  \t              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n  \t              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n  \t            );\n  \t            err.name = 'Invariant Violation';\n  \t            throw err;\n  \t          }\n  \t          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n  \t        } catch (ex) {\n  \t          error = ex;\n  \t        }\n  \t        if (error && !(error instanceof Error)) {\n  \t          printWarning(\n  \t            (componentName || 'React class') + ': type specification of ' +\n  \t            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n  \t            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n  \t            'You may have forgotten to pass an argument to the type checker ' +\n  \t            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n  \t            'shape all require an argument).'\n  \t          );\n  \t        }\n  \t        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n  \t          // Only monitor this failure once because there tends to be a lot of the\n  \t          // same error.\n  \t          loggedTypeFailures[error.message] = true;\n\n  \t          var stack = getStack ? getStack() : '';\n\n  \t          printWarning(\n  \t            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n  \t          );\n  \t        }\n  \t      }\n  \t    }\n  \t  }\n  \t}\n\n  \t/**\n  \t * Resets warning cache when testing.\n  \t *\n  \t * @private\n  \t */\n  \tcheckPropTypes.resetWarningCache = function() {\n  \t  if (true) {\n  \t    loggedTypeFailures = {};\n  \t  }\n  \t};\n\n  \tcheckPropTypes_1 = checkPropTypes;\n  \treturn checkPropTypes_1;\n  }\n\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var factoryWithTypeCheckers;\n  var hasRequiredFactoryWithTypeCheckers;\n\n  function requireFactoryWithTypeCheckers () {\n  \tif (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;\n  \thasRequiredFactoryWithTypeCheckers = 1;\n\n  \tvar ReactIs = requireReactIs();\n  \tvar assign = requireObjectAssign();\n\n  \tvar ReactPropTypesSecret = requireReactPropTypesSecret();\n  \tvar has = requireHas();\n  \tvar checkPropTypes = requireCheckPropTypes();\n\n  \tvar printWarning = function() {};\n\n  \tif (true) {\n  \t  printWarning = function(text) {\n  \t    var message = 'Warning: ' + text;\n  \t    if (typeof console !== 'undefined') {\n  \t      console.error(message);\n  \t    }\n  \t    try {\n  \t      // --- Welcome to debugging React ---\n  \t      // This error was thrown as a convenience so that you can use this stack\n  \t      // to find the callsite that caused this warning to fire.\n  \t      throw new Error(message);\n  \t    } catch (x) {}\n  \t  };\n  \t}\n\n  \tfunction emptyFunctionThatReturnsNull() {\n  \t  return null;\n  \t}\n\n  \tfactoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {\n  \t  /* global Symbol */\n  \t  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  \t  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  \t  /**\n  \t   * Returns the iterator method function contained on the iterable object.\n  \t   *\n  \t   * Be sure to invoke the function with the iterable as context:\n  \t   *\n  \t   *     var iteratorFn = getIteratorFn(myIterable);\n  \t   *     if (iteratorFn) {\n  \t   *       var iterator = iteratorFn.call(myIterable);\n  \t   *       ...\n  \t   *     }\n  \t   *\n  \t   * @param {?object} maybeIterable\n  \t   * @return {?function}\n  \t   */\n  \t  function getIteratorFn(maybeIterable) {\n  \t    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n  \t    if (typeof iteratorFn === 'function') {\n  \t      return iteratorFn;\n  \t    }\n  \t  }\n\n  \t  /**\n  \t   * Collection of methods that allow declaration and validation of props that are\n  \t   * supplied to React components. Example usage:\n  \t   *\n  \t   *   var Props = require('ReactPropTypes');\n  \t   *   var MyArticle = React.createClass({\n  \t   *     propTypes: {\n  \t   *       // An optional string prop named \"description\".\n  \t   *       description: Props.string,\n  \t   *\n  \t   *       // A required enum prop named \"category\".\n  \t   *       category: Props.oneOf(['News','Photos']).isRequired,\n  \t   *\n  \t   *       // A prop named \"dialog\" that requires an instance of Dialog.\n  \t   *       dialog: Props.instanceOf(Dialog).isRequired\n  \t   *     },\n  \t   *     render: function() { ... }\n  \t   *   });\n  \t   *\n  \t   * A more formal specification of how these methods are used:\n  \t   *\n  \t   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n  \t   *   decl := ReactPropTypes.{type}(.isRequired)?\n  \t   *\n  \t   * Each and every declaration produces a function with the same signature. This\n  \t   * allows the creation of custom validation functions. For example:\n  \t   *\n  \t   *  var MyLink = React.createClass({\n  \t   *    propTypes: {\n  \t   *      // An optional string or URI prop named \"href\".\n  \t   *      href: function(props, propName, componentName) {\n  \t   *        var propValue = props[propName];\n  \t   *        if (propValue != null && typeof propValue !== 'string' &&\n  \t   *            !(propValue instanceof URI)) {\n  \t   *          return new Error(\n  \t   *            'Expected a string or an URI for ' + propName + ' in ' +\n  \t   *            componentName\n  \t   *          );\n  \t   *        }\n  \t   *      }\n  \t   *    },\n  \t   *    render: function() {...}\n  \t   *  });\n  \t   *\n  \t   * @internal\n  \t   */\n\n  \t  var ANONYMOUS = '<<anonymous>>';\n\n  \t  // Important!\n  \t  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  \t  var ReactPropTypes = {\n  \t    array: createPrimitiveTypeChecker('array'),\n  \t    bigint: createPrimitiveTypeChecker('bigint'),\n  \t    bool: createPrimitiveTypeChecker('boolean'),\n  \t    func: createPrimitiveTypeChecker('function'),\n  \t    number: createPrimitiveTypeChecker('number'),\n  \t    object: createPrimitiveTypeChecker('object'),\n  \t    string: createPrimitiveTypeChecker('string'),\n  \t    symbol: createPrimitiveTypeChecker('symbol'),\n\n  \t    any: createAnyTypeChecker(),\n  \t    arrayOf: createArrayOfTypeChecker,\n  \t    element: createElementTypeChecker(),\n  \t    elementType: createElementTypeTypeChecker(),\n  \t    instanceOf: createInstanceTypeChecker,\n  \t    node: createNodeChecker(),\n  \t    objectOf: createObjectOfTypeChecker,\n  \t    oneOf: createEnumTypeChecker,\n  \t    oneOfType: createUnionTypeChecker,\n  \t    shape: createShapeTypeChecker,\n  \t    exact: createStrictShapeTypeChecker,\n  \t  };\n\n  \t  /**\n  \t   * inlined Object.is polyfill to avoid requiring consumers ship their own\n  \t   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n  \t   */\n  \t  /*eslint-disable no-self-compare*/\n  \t  function is(x, y) {\n  \t    // SameValue algorithm\n  \t    if (x === y) {\n  \t      // Steps 1-5, 7-10\n  \t      // Steps 6.b-6.e: +0 != -0\n  \t      return x !== 0 || 1 / x === 1 / y;\n  \t    } else {\n  \t      // Step 6.a: NaN == NaN\n  \t      return x !== x && y !== y;\n  \t    }\n  \t  }\n  \t  /*eslint-enable no-self-compare*/\n\n  \t  /**\n  \t   * We use an Error-like object for backward compatibility as people may call\n  \t   * PropTypes directly and inspect their output. However, we don't use real\n  \t   * Errors anymore. We don't inspect their stack anyway, and creating them\n  \t   * is prohibitively expensive if they are created too often, such as what\n  \t   * happens in oneOfType() for any type before the one that matched.\n  \t   */\n  \t  function PropTypeError(message, data) {\n  \t    this.message = message;\n  \t    this.data = data && typeof data === 'object' ? data: {};\n  \t    this.stack = '';\n  \t  }\n  \t  // Make `instanceof Error` still work for returned errors.\n  \t  PropTypeError.prototype = Error.prototype;\n\n  \t  function createChainableTypeChecker(validate) {\n  \t    if (true) {\n  \t      var manualPropTypeCallCache = {};\n  \t      var manualPropTypeWarningCount = 0;\n  \t    }\n  \t    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n  \t      componentName = componentName || ANONYMOUS;\n  \t      propFullName = propFullName || propName;\n\n  \t      if (secret !== ReactPropTypesSecret) {\n  \t        if (throwOnDirectAccess) {\n  \t          // New behavior only for users of `prop-types` package\n  \t          var err = new Error(\n  \t            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n  \t            'Use `PropTypes.checkPropTypes()` to call them. ' +\n  \t            'Read more at http://fb.me/use-check-prop-types'\n  \t          );\n  \t          err.name = 'Invariant Violation';\n  \t          throw err;\n  \t        } else if ( true && typeof console !== 'undefined') {\n  \t          // Old behavior for people using React.PropTypes\n  \t          var cacheKey = componentName + ':' + propName;\n  \t          if (\n  \t            !manualPropTypeCallCache[cacheKey] &&\n  \t            // Avoid spamming the console because they are often not actionable except for lib authors\n  \t            manualPropTypeWarningCount < 3\n  \t          ) {\n  \t            printWarning(\n  \t              'You are manually calling a React.PropTypes validation ' +\n  \t              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n  \t              'and will throw in the standalone `prop-types` package. ' +\n  \t              'You may be seeing this warning due to a third-party PropTypes ' +\n  \t              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n  \t            );\n  \t            manualPropTypeCallCache[cacheKey] = true;\n  \t            manualPropTypeWarningCount++;\n  \t          }\n  \t        }\n  \t      }\n  \t      if (props[propName] == null) {\n  \t        if (isRequired) {\n  \t          if (props[propName] === null) {\n  \t            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n  \t          }\n  \t          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n  \t        }\n  \t        return null;\n  \t      } else {\n  \t        return validate(props, propName, componentName, location, propFullName);\n  \t      }\n  \t    }\n\n  \t    var chainedCheckType = checkType.bind(null, false);\n  \t    chainedCheckType.isRequired = checkType.bind(null, true);\n\n  \t    return chainedCheckType;\n  \t  }\n\n  \t  function createPrimitiveTypeChecker(expectedType) {\n  \t    function validate(props, propName, componentName, location, propFullName, secret) {\n  \t      var propValue = props[propName];\n  \t      var propType = getPropType(propValue);\n  \t      if (propType !== expectedType) {\n  \t        // `propValue` being instance of, say, date/regexp, pass the 'object'\n  \t        // check, but we can offer a more precise error message here rather than\n  \t        // 'of type `object`'.\n  \t        var preciseType = getPreciseType(propValue);\n\n  \t        return new PropTypeError(\n  \t          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n  \t          {expectedType: expectedType}\n  \t        );\n  \t      }\n  \t      return null;\n  \t    }\n  \t    return createChainableTypeChecker(validate);\n  \t  }\n\n  \t  function createAnyTypeChecker() {\n  \t    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  \t  }\n\n  \t  function createArrayOfTypeChecker(typeChecker) {\n  \t    function validate(props, propName, componentName, location, propFullName) {\n  \t      if (typeof typeChecker !== 'function') {\n  \t        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n  \t      }\n  \t      var propValue = props[propName];\n  \t      if (!Array.isArray(propValue)) {\n  \t        var propType = getPropType(propValue);\n  \t        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n  \t      }\n  \t      for (var i = 0; i < propValue.length; i++) {\n  \t        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n  \t        if (error instanceof Error) {\n  \t          return error;\n  \t        }\n  \t      }\n  \t      return null;\n  \t    }\n  \t    return createChainableTypeChecker(validate);\n  \t  }\n\n  \t  function createElementTypeChecker() {\n  \t    function validate(props, propName, componentName, location, propFullName) {\n  \t      var propValue = props[propName];\n  \t      if (!isValidElement(propValue)) {\n  \t        var propType = getPropType(propValue);\n  \t        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n  \t      }\n  \t      return null;\n  \t    }\n  \t    return createChainableTypeChecker(validate);\n  \t  }\n\n  \t  function createElementTypeTypeChecker() {\n  \t    function validate(props, propName, componentName, location, propFullName) {\n  \t      var propValue = props[propName];\n  \t      if (!ReactIs.isValidElementType(propValue)) {\n  \t        var propType = getPropType(propValue);\n  \t        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n  \t      }\n  \t      return null;\n  \t    }\n  \t    return createChainableTypeChecker(validate);\n  \t  }\n\n  \t  function createInstanceTypeChecker(expectedClass) {\n  \t    function validate(props, propName, componentName, location, propFullName) {\n  \t      if (!(props[propName] instanceof expectedClass)) {\n  \t        var expectedClassName = expectedClass.name || ANONYMOUS;\n  \t        var actualClassName = getClassName(props[propName]);\n  \t        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n  \t      }\n  \t      return null;\n  \t    }\n  \t    return createChainableTypeChecker(validate);\n  \t  }\n\n  \t  function createEnumTypeChecker(expectedValues) {\n  \t    if (!Array.isArray(expectedValues)) {\n  \t      if (true) {\n  \t        if (arguments.length > 1) {\n  \t          printWarning(\n  \t            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n  \t            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n  \t          );\n  \t        } else {\n  \t          printWarning('Invalid argument supplied to oneOf, expected an array.');\n  \t        }\n  \t      }\n  \t      return emptyFunctionThatReturnsNull;\n  \t    }\n\n  \t    function validate(props, propName, componentName, location, propFullName) {\n  \t      var propValue = props[propName];\n  \t      for (var i = 0; i < expectedValues.length; i++) {\n  \t        if (is(propValue, expectedValues[i])) {\n  \t          return null;\n  \t        }\n  \t      }\n\n  \t      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n  \t        var type = getPreciseType(value);\n  \t        if (type === 'symbol') {\n  \t          return String(value);\n  \t        }\n  \t        return value;\n  \t      });\n  \t      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n  \t    }\n  \t    return createChainableTypeChecker(validate);\n  \t  }\n\n  \t  function createObjectOfTypeChecker(typeChecker) {\n  \t    function validate(props, propName, componentName, location, propFullName) {\n  \t      if (typeof typeChecker !== 'function') {\n  \t        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n  \t      }\n  \t      var propValue = props[propName];\n  \t      var propType = getPropType(propValue);\n  \t      if (propType !== 'object') {\n  \t        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n  \t      }\n  \t      for (var key in propValue) {\n  \t        if (has(propValue, key)) {\n  \t          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n  \t          if (error instanceof Error) {\n  \t            return error;\n  \t          }\n  \t        }\n  \t      }\n  \t      return null;\n  \t    }\n  \t    return createChainableTypeChecker(validate);\n  \t  }\n\n  \t  function createUnionTypeChecker(arrayOfTypeCheckers) {\n  \t    if (!Array.isArray(arrayOfTypeCheckers)) {\n  \t       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n  \t      return emptyFunctionThatReturnsNull;\n  \t    }\n\n  \t    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n  \t      var checker = arrayOfTypeCheckers[i];\n  \t      if (typeof checker !== 'function') {\n  \t        printWarning(\n  \t          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n  \t          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n  \t        );\n  \t        return emptyFunctionThatReturnsNull;\n  \t      }\n  \t    }\n\n  \t    function validate(props, propName, componentName, location, propFullName) {\n  \t      var expectedTypes = [];\n  \t      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n  \t        var checker = arrayOfTypeCheckers[i];\n  \t        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n  \t        if (checkerResult == null) {\n  \t          return null;\n  \t        }\n  \t        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n  \t          expectedTypes.push(checkerResult.data.expectedType);\n  \t        }\n  \t      }\n  \t      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n  \t      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n  \t    }\n  \t    return createChainableTypeChecker(validate);\n  \t  }\n\n  \t  function createNodeChecker() {\n  \t    function validate(props, propName, componentName, location, propFullName) {\n  \t      if (!isNode(props[propName])) {\n  \t        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n  \t      }\n  \t      return null;\n  \t    }\n  \t    return createChainableTypeChecker(validate);\n  \t  }\n\n  \t  function invalidValidatorError(componentName, location, propFullName, key, type) {\n  \t    return new PropTypeError(\n  \t      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n  \t      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n  \t    );\n  \t  }\n\n  \t  function createShapeTypeChecker(shapeTypes) {\n  \t    function validate(props, propName, componentName, location, propFullName) {\n  \t      var propValue = props[propName];\n  \t      var propType = getPropType(propValue);\n  \t      if (propType !== 'object') {\n  \t        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n  \t      }\n  \t      for (var key in shapeTypes) {\n  \t        var checker = shapeTypes[key];\n  \t        if (typeof checker !== 'function') {\n  \t          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n  \t        }\n  \t        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n  \t        if (error) {\n  \t          return error;\n  \t        }\n  \t      }\n  \t      return null;\n  \t    }\n  \t    return createChainableTypeChecker(validate);\n  \t  }\n\n  \t  function createStrictShapeTypeChecker(shapeTypes) {\n  \t    function validate(props, propName, componentName, location, propFullName) {\n  \t      var propValue = props[propName];\n  \t      var propType = getPropType(propValue);\n  \t      if (propType !== 'object') {\n  \t        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n  \t      }\n  \t      // We need to check all keys in case some are required but missing from props.\n  \t      var allKeys = assign({}, props[propName], shapeTypes);\n  \t      for (var key in allKeys) {\n  \t        var checker = shapeTypes[key];\n  \t        if (has(shapeTypes, key) && typeof checker !== 'function') {\n  \t          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n  \t        }\n  \t        if (!checker) {\n  \t          return new PropTypeError(\n  \t            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n  \t            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n  \t            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n  \t          );\n  \t        }\n  \t        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n  \t        if (error) {\n  \t          return error;\n  \t        }\n  \t      }\n  \t      return null;\n  \t    }\n\n  \t    return createChainableTypeChecker(validate);\n  \t  }\n\n  \t  function isNode(propValue) {\n  \t    switch (typeof propValue) {\n  \t      case 'number':\n  \t      case 'string':\n  \t      case 'undefined':\n  \t        return true;\n  \t      case 'boolean':\n  \t        return !propValue;\n  \t      case 'object':\n  \t        if (Array.isArray(propValue)) {\n  \t          return propValue.every(isNode);\n  \t        }\n  \t        if (propValue === null || isValidElement(propValue)) {\n  \t          return true;\n  \t        }\n\n  \t        var iteratorFn = getIteratorFn(propValue);\n  \t        if (iteratorFn) {\n  \t          var iterator = iteratorFn.call(propValue);\n  \t          var step;\n  \t          if (iteratorFn !== propValue.entries) {\n  \t            while (!(step = iterator.next()).done) {\n  \t              if (!isNode(step.value)) {\n  \t                return false;\n  \t              }\n  \t            }\n  \t          } else {\n  \t            // Iterator will provide entry [k,v] tuples rather than values.\n  \t            while (!(step = iterator.next()).done) {\n  \t              var entry = step.value;\n  \t              if (entry) {\n  \t                if (!isNode(entry[1])) {\n  \t                  return false;\n  \t                }\n  \t              }\n  \t            }\n  \t          }\n  \t        } else {\n  \t          return false;\n  \t        }\n\n  \t        return true;\n  \t      default:\n  \t        return false;\n  \t    }\n  \t  }\n\n  \t  function isSymbol(propType, propValue) {\n  \t    // Native Symbol.\n  \t    if (propType === 'symbol') {\n  \t      return true;\n  \t    }\n\n  \t    // falsy value can't be a Symbol\n  \t    if (!propValue) {\n  \t      return false;\n  \t    }\n\n  \t    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n  \t    if (propValue['@@toStringTag'] === 'Symbol') {\n  \t      return true;\n  \t    }\n\n  \t    // Fallback for non-spec compliant Symbols which are polyfilled.\n  \t    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n  \t      return true;\n  \t    }\n\n  \t    return false;\n  \t  }\n\n  \t  // Equivalent of `typeof` but with special handling for array and regexp.\n  \t  function getPropType(propValue) {\n  \t    var propType = typeof propValue;\n  \t    if (Array.isArray(propValue)) {\n  \t      return 'array';\n  \t    }\n  \t    if (propValue instanceof RegExp) {\n  \t      // Old webkits (at least until Android 4.0) return 'function' rather than\n  \t      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n  \t      // passes PropTypes.object.\n  \t      return 'object';\n  \t    }\n  \t    if (isSymbol(propType, propValue)) {\n  \t      return 'symbol';\n  \t    }\n  \t    return propType;\n  \t  }\n\n  \t  // This handles more types than `getPropType`. Only used for error messages.\n  \t  // See `createPrimitiveTypeChecker`.\n  \t  function getPreciseType(propValue) {\n  \t    if (typeof propValue === 'undefined' || propValue === null) {\n  \t      return '' + propValue;\n  \t    }\n  \t    var propType = getPropType(propValue);\n  \t    if (propType === 'object') {\n  \t      if (propValue instanceof Date) {\n  \t        return 'date';\n  \t      } else if (propValue instanceof RegExp) {\n  \t        return 'regexp';\n  \t      }\n  \t    }\n  \t    return propType;\n  \t  }\n\n  \t  // Returns a string that is postfixed to a warning about an invalid type.\n  \t  // For example, \"undefined\" or \"of type array\"\n  \t  function getPostfixForTypeWarning(value) {\n  \t    var type = getPreciseType(value);\n  \t    switch (type) {\n  \t      case 'array':\n  \t      case 'object':\n  \t        return 'an ' + type;\n  \t      case 'boolean':\n  \t      case 'date':\n  \t      case 'regexp':\n  \t        return 'a ' + type;\n  \t      default:\n  \t        return type;\n  \t    }\n  \t  }\n\n  \t  // Returns class name of the object, if any.\n  \t  function getClassName(propValue) {\n  \t    if (!propValue.constructor || !propValue.constructor.name) {\n  \t      return ANONYMOUS;\n  \t    }\n  \t    return propValue.constructor.name;\n  \t  }\n\n  \t  ReactPropTypes.checkPropTypes = checkPropTypes;\n  \t  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  \t  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  \t  return ReactPropTypes;\n  \t};\n  \treturn factoryWithTypeCheckers;\n  }\n\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var factoryWithThrowingShims;\n  var hasRequiredFactoryWithThrowingShims;\n\n  function requireFactoryWithThrowingShims () {\n  \tif (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;\n  \thasRequiredFactoryWithThrowingShims = 1;\n\n  \tvar ReactPropTypesSecret = requireReactPropTypesSecret();\n\n  \tfunction emptyFunction() {}\n  \tfunction emptyFunctionWithReset() {}\n  \temptyFunctionWithReset.resetWarningCache = emptyFunction;\n\n  \tfactoryWithThrowingShims = function() {\n  \t  function shim(props, propName, componentName, location, propFullName, secret) {\n  \t    if (secret === ReactPropTypesSecret) {\n  \t      // It is still safe when called from React.\n  \t      return;\n  \t    }\n  \t    var err = new Error(\n  \t      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n  \t      'Use PropTypes.checkPropTypes() to call them. ' +\n  \t      'Read more at http://fb.me/use-check-prop-types'\n  \t    );\n  \t    err.name = 'Invariant Violation';\n  \t    throw err;\n  \t  }\t  shim.isRequired = shim;\n  \t  function getShim() {\n  \t    return shim;\n  \t  }\t  // Important!\n  \t  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  \t  var ReactPropTypes = {\n  \t    array: shim,\n  \t    bigint: shim,\n  \t    bool: shim,\n  \t    func: shim,\n  \t    number: shim,\n  \t    object: shim,\n  \t    string: shim,\n  \t    symbol: shim,\n\n  \t    any: shim,\n  \t    arrayOf: getShim,\n  \t    element: shim,\n  \t    elementType: shim,\n  \t    instanceOf: getShim,\n  \t    node: shim,\n  \t    objectOf: getShim,\n  \t    oneOf: getShim,\n  \t    oneOfType: getShim,\n  \t    shape: getShim,\n  \t    exact: getShim,\n\n  \t    checkPropTypes: emptyFunctionWithReset,\n  \t    resetWarningCache: emptyFunction\n  \t  };\n\n  \t  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  \t  return ReactPropTypes;\n  \t};\n  \treturn factoryWithThrowingShims;\n  }\n\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  if (true) {\n    var ReactIs = requireReactIs();\n\n    // By explicitly using `prop-types` you are opting into new development behavior.\n    // http://fb.me/prop-types-in-prod\n    var throwOnDirectAccess = true;\n    propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);\n  } else {}\n\n  /* eslint-disable react-hooks/exhaustive-deps */\n\n  /**\n   * useEventListener\n   * Hook for handling EventListeners\n   * @return {object} width, height\n   */\n\n  function useEventListener(eventName, handler, element = window) {\n    // Create a ref that stores handler\n    const savedHandler = React.useRef(); // Update ref.current value if handler changes.\n\n    React.useEffect(() => {\n      savedHandler.current = handler;\n    }, [handler]);\n    React.useEffect(() => {\n      // Make sure element supports addEventListener\n      const isSupported = element && element.addEventListener;\n      if (!isSupported) return; // Create event listener that calls handler function stored in ref\n\n      const eventListener = event => savedHandler.current(event); // Add event listener\n\n\n      element.addEventListener(eventName, eventListener); // Remove event listener on cleanup\n\n      return () => {\n        element.removeEventListener(eventName, eventListener);\n      };\n    }, [eventName, element] // Re-run if eventName or element changes\n    );\n  }\n\n  const IsDevice = (() => {\n    if (typeof navigator == 'undefined') return;\n    let ua = navigator.userAgent;\n    return {\n      info: ua,\n\n      Android() {\n        return ua.match(/Android/i);\n      },\n\n      BlackBerry() {\n        return ua.match(/BlackBerry/i);\n      },\n\n      IEMobile() {\n        return ua.match(/IEMobile/i);\n      },\n\n      iOS() {\n        return ua.match(/iPhone|iPad|iPod/i);\n      },\n\n      iPad() {\n        return ua.match(/Mac/) && navigator.maxTouchPoints && navigator.maxTouchPoints > 2;\n      },\n\n      OperaMini() {\n        return ua.match(/Opera Mini/i);\n      },\n\n      /**\n       * Any Device\n       */\n      any() {\n        return IsDevice.Android() || IsDevice.BlackBerry() || IsDevice.iOS() || IsDevice.iPad() || IsDevice.OperaMini() || IsDevice.IEMobile();\n      }\n\n    };\n  })(); // Export\n\n  /**\n   * Cursor Core\n   * Replaces the native cursor with a custom animated cursor, consisting\n   * of an inner and outer dot that scale inversely based on hover or click.\n   *\n   * @author Stephen Scaff (github.com/stephenscaff)\n   *\n   * @param {string} color - rgb color value\n   * @param {number} outerAlpha - level of alpha transparency for color\n   * @param {number} innerSize - inner cursor size in px\n   * @param {number} innerScale - inner cursor scale amount\n   * @param {number} outerSize - outer cursor size in px\n   * @param {number} outerScale - outer cursor scale amount\n   * @param {object} outerStyle - style object for outer cursor\n   * @param {object} innerStyle - style object for inner cursor\n   * @param {array}  clickables - array of clickable selectors\n   *\n   */\n\n  function CursorCore({\n    outerStyle,\n    innerStyle,\n    color = '220, 90, 90',\n    outerAlpha = 0.3,\n    innerSize = 8,\n    outerSize = 8,\n    outerScale = 6,\n    innerScale = 0.6,\n    trailingSpeed = 8,\n    clickables = ['a', 'input[type=\"text\"]', 'input[type=\"email\"]', 'input[type=\"number\"]', 'input[type=\"submit\"]', 'input[type=\"image\"]', 'label[for]', 'select', 'textarea', 'button', '.link']\n  }) {\n    const cursorOuterRef = React.useRef();\n    const cursorInnerRef = React.useRef();\n    const requestRef = React.useRef();\n    const previousTimeRef = React.useRef();\n    const [coords, setCoords] = React.useState({\n      x: 0,\n      y: 0\n    });\n    const [isVisible, setIsVisible] = React.useState(false);\n    const [isActive, setIsActive] = React.useState(false);\n    const [isActiveClickable, setIsActiveClickable] = React.useState(false);\n    let endX = React.useRef(0);\n    let endY = React.useRef(0);\n    /**\n     * Primary Mouse move event\n     * @param {number} clientX - MouseEvent.clientx\n     * @param {number} clientY - MouseEvent.clienty\n     */\n\n    const onMouseMove = React.useCallback(({\n      clientX,\n      clientY\n    }) => {\n      setCoords({\n        x: clientX,\n        y: clientY\n      });\n      cursorInnerRef.current.style.top = `${clientY}px`;\n      cursorInnerRef.current.style.left = `${clientX}px`;\n      endX.current = clientX;\n      endY.current = clientY;\n    }, []); // Outer Cursor Animation Delay\n\n    const animateOuterCursor = React.useCallback(time => {\n      if (previousTimeRef.current !== undefined) {\n        coords.x += (endX.current - coords.x) / trailingSpeed;\n        coords.y += (endY.current - coords.y) / trailingSpeed;\n        cursorOuterRef.current.style.top = `${coords.y}px`;\n        cursorOuterRef.current.style.left = `${coords.x}px`;\n      }\n\n      previousTimeRef.current = time;\n      requestRef.current = requestAnimationFrame(animateOuterCursor);\n    }, [requestRef] // eslint-disable-line\n    ); // RAF for animateOuterCursor\n\n    React.useEffect(() => {\n      requestRef.current = requestAnimationFrame(animateOuterCursor);\n      return () => cancelAnimationFrame(requestRef.current);\n    }, [animateOuterCursor]); // Mouse Events State updates\n\n    const onMouseDown = React.useCallback(() => setIsActive(true), []);\n    const onMouseUp = React.useCallback(() => setIsActive(false), []);\n    const onMouseEnterViewport = React.useCallback(() => setIsVisible(true), []);\n    const onMouseLeaveViewport = React.useCallback(() => setIsVisible(false), []);\n    useEventListener('mousemove', onMouseMove);\n    useEventListener('mousedown', onMouseDown);\n    useEventListener('mouseup', onMouseUp);\n    useEventListener('mouseover', onMouseEnterViewport);\n    useEventListener('mouseout', onMouseLeaveViewport); // Cursors Hover/Active State\n\n    React.useEffect(() => {\n      if (isActive) {\n        cursorInnerRef.current.style.transform = `translate(-50%, -50%) scale(${innerScale})`;\n        cursorOuterRef.current.style.transform = `translate(-50%, -50%) scale(${outerScale})`;\n      } else {\n        cursorInnerRef.current.style.transform = 'translate(-50%, -50%) scale(1)';\n        cursorOuterRef.current.style.transform = 'translate(-50%, -50%) scale(1)';\n      }\n    }, [innerScale, outerScale, isActive]); // Cursors Click States\n\n    React.useEffect(() => {\n      if (isActiveClickable) {\n        cursorInnerRef.current.style.transform = `translate(-50%, -50%) scale(${innerScale * 1.2})`;\n        cursorOuterRef.current.style.transform = `translate(-50%, -50%) scale(${outerScale * 1.4})`;\n      }\n    }, [innerScale, outerScale, isActiveClickable]); // Cursor Visibility State\n\n    React.useEffect(() => {\n      if (isVisible) {\n        cursorInnerRef.current.style.opacity = 1;\n        cursorOuterRef.current.style.opacity = 1;\n      } else {\n        cursorInnerRef.current.style.opacity = 0;\n        cursorOuterRef.current.style.opacity = 0;\n      }\n    }, [isVisible]);\n    React.useEffect(() => {\n      const clickableEls = document.querySelectorAll(clickables.join(','));\n      clickableEls.forEach(el => {\n        el.style.cursor = 'none';\n        el.addEventListener('mouseover', () => {\n          setIsActive(true);\n        });\n        el.addEventListener('click', () => {\n          setIsActive(true);\n          setIsActiveClickable(false);\n        });\n        el.addEventListener('mousedown', () => {\n          setIsActiveClickable(true);\n        });\n        el.addEventListener('mouseup', () => {\n          setIsActive(true);\n        });\n        el.addEventListener('mouseout', () => {\n          setIsActive(false);\n          setIsActiveClickable(false);\n        });\n      });\n      return () => {\n        clickableEls.forEach(el => {\n          el.removeEventListener('mouseover', () => {\n            setIsActive(true);\n          });\n          el.removeEventListener('click', () => {\n            setIsActive(true);\n            setIsActiveClickable(false);\n          });\n          el.removeEventListener('mousedown', () => {\n            setIsActiveClickable(true);\n          });\n          el.removeEventListener('mouseup', () => {\n            setIsActive(true);\n          });\n          el.removeEventListener('mouseout', () => {\n            setIsActive(false);\n            setIsActiveClickable(false);\n          });\n        });\n      };\n    }, [isActive, clickables]); // Cursor Styles\n\n    const styles = {\n      cursorInner: {\n        zIndex: 999,\n        display: 'block',\n        position: 'fixed',\n        borderRadius: '50%',\n        width: innerSize,\n        height: innerSize,\n        pointerEvents: 'none',\n        backgroundColor: `rgba(${color}, 1)`,\n        ...(innerStyle && innerStyle),\n        transition: 'opacity 0.15s ease-in-out, transform 0.25s ease-in-out'\n      },\n      cursorOuter: {\n        zIndex: 999,\n        display: 'block',\n        position: 'fixed',\n        borderRadius: '50%',\n        pointerEvents: 'none',\n        width: outerSize,\n        height: outerSize,\n        backgroundColor: `rgba(${color}, ${outerAlpha})`,\n        transition: 'opacity 0.15s ease-in-out, transform 0.15s ease-in-out',\n        willChange: 'transform',\n        ...(outerStyle && outerStyle)\n      }\n    }; // Hide / Show global cursor\n\n    document.body.style.cursor = 'none';\n    return /*#__PURE__*/React__default[\"default\"].createElement(React__default[\"default\"].Fragment, null, /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n      ref: cursorOuterRef,\n      style: styles.cursorOuter\n    }), /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n      ref: cursorInnerRef,\n      style: styles.cursorInner\n    }));\n  }\n  /**\n   * AnimatedCursor\n   * Calls and passes props to CursorCore if not a touch/mobile device.\n   */\n\n\n  function AnimatedCursor({\n    outerStyle,\n    innerStyle,\n    color,\n    outerAlpha,\n    innerSize,\n    innerScale,\n    outerSize,\n    outerScale,\n    trailingSpeed,\n    clickables\n  }) {\n    if (typeof navigator !== 'undefined' && IsDevice.any()) {\n      return /*#__PURE__*/React__default[\"default\"].createElement(React__default[\"default\"].Fragment, null);\n    }\n\n    return /*#__PURE__*/React__default[\"default\"].createElement(CursorCore, {\n      outerStyle: outerStyle,\n      innerStyle: innerStyle,\n      color: color,\n      outerAlpha: outerAlpha,\n      innerSize: innerSize,\n      innerScale: innerScale,\n      outerSize: outerSize,\n      outerScale: outerScale,\n      trailingSpeed: trailingSpeed,\n      clickables: clickables\n    });\n  }\n\n  AnimatedCursor.propTypes = {\n    color: propTypes.exports.string,\n    outerAlpha: propTypes.exports.number,\n    innerSize: propTypes.exports.number,\n    outerSize: propTypes.exports.number,\n    outerScale: propTypes.exports.number,\n    innerScale: propTypes.exports.number,\n    outerStyle: propTypes.exports.object,\n    innerStyle: propTypes.exports.object,\n    trailingSpeed: propTypes.exports.number,\n    clickables: propTypes.exports.array\n  };\n\n  return AnimatedCursor;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWFuaW1hdGVkLWN1cnNvci9kaXN0L2luZGV4LnVtZC5qcz9hNWMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsRUFBRSxLQUE0RCw0QkFBNEIsbUJBQU8sQ0FBQyw0Q0FBTztBQUN6RyxFQUFFLENBQ3lIO0FBQzNILENBQUMsMkJBQTJCOztBQUU1QixzQ0FBc0MsNERBQTRELGdCQUFnQjs7QUFFbEg7O0FBRUEsbUJBQW1COztBQUVuQixpQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQ0FBa0MsaUJBQWlCLFVBQVUsMEJBQTBCLG1EQUFtRCxrQ0FBa0MsNENBQTRDLGtCQUFrQixrQkFBa0IsY0FBYyxnQkFBZ0IsbUNBQW1DLHdDQUF3Qyx5Q0FBeUMseUNBQXlDLGlDQUFpQyxvQ0FBb0Msa0NBQWtDLDhCQUE4Qiw4QkFBOEI7QUFDM21CLHFDQUFxQyxvQ0FBb0Msa0NBQWtDLCtDQUErQyx1QkFBdUIsMENBQTBDLHFEQUFxRCxpQkFBaUIscURBQXFELGlCQUFpQiw2Q0FBNkMsc0RBQXNELGdEQUFnRCxpQkFBaUIsOENBQThDLGlCQUFpQiwwQ0FBMEM7QUFDcG5CLDZDQUE2QyxpQkFBaUIsNENBQTRDLGlCQUFpQiw4Q0FBOEMsaUJBQWlCLGdEQUFnRCxpQkFBaUIsOENBQThDO0FBQ3pTLHlEQUF5RCw4UUFBOFE7QUFDdlU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBLE9BQU8sSUFBcUM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTyxJQUFxQztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQXFDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU8sSUFBcUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixnQ0FBZ0M7QUFDaEMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwrQkFBK0I7QUFDL0IsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBcUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVLEtBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxJQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDLDRGQUE0RixDQUFNO0FBQ2hKO0FBQ0E7O0FBRUEsc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1IQUFtSDtBQUNuSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxJQUFxQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsTUFBTSxFQUlOOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0IsaUVBQWlFOzs7QUFHakUseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0Q0FBNEMsUUFBUTtBQUNwRCw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0EsS0FBSyxNQUFNOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQsK0NBQStDLFNBQVM7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLEtBQUssd0JBQXdCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0EsZ0ZBQWdGLFdBQVc7QUFDM0YsZ0ZBQWdGLFdBQVc7QUFDM0YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0NBQXNDOztBQUUzQztBQUNBO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRyxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0EsS0FBSywrQ0FBK0M7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUssMEJBQTBCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTSxJQUFJLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC1hbmltYXRlZC1jdXJzb3IvZGlzdC9pbmRleC51bWQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgncmVhY3QnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydyZWFjdCddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5BbmltYXRlZEN1cnNvciA9IGZhY3RvcnkoZ2xvYmFsLlJlYWN0KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxuICB2YXIgUmVhY3RfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KFJlYWN0KTtcblxuICB2YXIgcHJvcFR5cGVzID0ge2V4cG9ydHM6IHt9fTtcblxuICB2YXIgcmVhY3RJcyA9IHtleHBvcnRzOiB7fX07XG5cbiAgdmFyIHJlYWN0SXNfcHJvZHVjdGlvbl9taW4gPSB7fTtcblxuICAvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAgICogcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanNcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gICAqXG4gICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gICAqL1xuXG4gIHZhciBoYXNSZXF1aXJlZFJlYWN0SXNfcHJvZHVjdGlvbl9taW47XG5cbiAgZnVuY3Rpb24gcmVxdWlyZVJlYWN0SXNfcHJvZHVjdGlvbl9taW4gKCkge1xuICBcdGlmIChoYXNSZXF1aXJlZFJlYWN0SXNfcHJvZHVjdGlvbl9taW4pIHJldHVybiByZWFjdElzX3Byb2R1Y3Rpb25fbWluO1xuICBcdGhhc1JlcXVpcmVkUmVhY3RJc19wcm9kdWN0aW9uX21pbiA9IDE7XG4gIHZhciBiPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3IsYz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLGQ9Yj9TeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LGU9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcsZj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTo2MDEwOCxnPWI/U3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpOjYwMTE0LGg9Yj9TeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik6NjAxMDksaz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpOjYwMTEwLGw9Yj9TeW1ib2wuZm9yKFwicmVhY3QuYXN5bmNfbW9kZVwiKTo2MDExMSxtPWI/U3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKTo2MDExMSxuPWI/U3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpOjYwMTEyLHA9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik6NjAxMTMscT1iP1xuICBcdFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpOjYwMTIwLHI9Yj9TeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTo2MDExNSx0PWI/U3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik6NjAxMTYsdj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKTo2MDEyMSx3PWI/U3ltYm9sLmZvcihcInJlYWN0LmZ1bmRhbWVudGFsXCIpOjYwMTE3LHg9Yj9TeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpOjYwMTE4LHk9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik6NjAxMTk7XG4gIFx0ZnVuY3Rpb24geihhKXtpZihcIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hKXt2YXIgdT1hLiQkdHlwZW9mO3N3aXRjaCh1KXtjYXNlIGM6c3dpdGNoKGE9YS50eXBlLGEpe2Nhc2UgbDpjYXNlIG06Y2FzZSBlOmNhc2UgZzpjYXNlIGY6Y2FzZSBwOnJldHVybiBhO2RlZmF1bHQ6c3dpdGNoKGE9YSYmYS4kJHR5cGVvZixhKXtjYXNlIGs6Y2FzZSBuOmNhc2UgdDpjYXNlIHI6Y2FzZSBoOnJldHVybiBhO2RlZmF1bHQ6cmV0dXJuIHV9fWNhc2UgZDpyZXR1cm4gdX19fWZ1bmN0aW9uIEEoYSl7cmV0dXJuIHooYSk9PT1tfXJlYWN0SXNfcHJvZHVjdGlvbl9taW4uQXN5bmNNb2RlPWw7cmVhY3RJc19wcm9kdWN0aW9uX21pbi5Db25jdXJyZW50TW9kZT1tO3JlYWN0SXNfcHJvZHVjdGlvbl9taW4uQ29udGV4dENvbnN1bWVyPWs7cmVhY3RJc19wcm9kdWN0aW9uX21pbi5Db250ZXh0UHJvdmlkZXI9aDtyZWFjdElzX3Byb2R1Y3Rpb25fbWluLkVsZW1lbnQ9YztyZWFjdElzX3Byb2R1Y3Rpb25fbWluLkZvcndhcmRSZWY9bjtyZWFjdElzX3Byb2R1Y3Rpb25fbWluLkZyYWdtZW50PWU7cmVhY3RJc19wcm9kdWN0aW9uX21pbi5MYXp5PXQ7cmVhY3RJc19wcm9kdWN0aW9uX21pbi5NZW1vPXI7cmVhY3RJc19wcm9kdWN0aW9uX21pbi5Qb3J0YWw9ZDtcbiAgXHRyZWFjdElzX3Byb2R1Y3Rpb25fbWluLlByb2ZpbGVyPWc7cmVhY3RJc19wcm9kdWN0aW9uX21pbi5TdHJpY3RNb2RlPWY7cmVhY3RJc19wcm9kdWN0aW9uX21pbi5TdXNwZW5zZT1wO3JlYWN0SXNfcHJvZHVjdGlvbl9taW4uaXNBc3luY01vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIEEoYSl8fHooYSk9PT1sfTtyZWFjdElzX3Byb2R1Y3Rpb25fbWluLmlzQ29uY3VycmVudE1vZGU9QTtyZWFjdElzX3Byb2R1Y3Rpb25fbWluLmlzQ29udGV4dENvbnN1bWVyPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09a307cmVhY3RJc19wcm9kdWN0aW9uX21pbi5pc0NvbnRleHRQcm92aWRlcj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWh9O3JlYWN0SXNfcHJvZHVjdGlvbl9taW4uaXNFbGVtZW50PWZ1bmN0aW9uKGEpe3JldHVybiBcIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09Y307cmVhY3RJc19wcm9kdWN0aW9uX21pbi5pc0ZvcndhcmRSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ufTtyZWFjdElzX3Byb2R1Y3Rpb25fbWluLmlzRnJhZ21lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1lfTtyZWFjdElzX3Byb2R1Y3Rpb25fbWluLmlzTGF6eT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXR9O1xuICBcdHJlYWN0SXNfcHJvZHVjdGlvbl9taW4uaXNNZW1vPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09cn07cmVhY3RJc19wcm9kdWN0aW9uX21pbi5pc1BvcnRhbD1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWR9O3JlYWN0SXNfcHJvZHVjdGlvbl9taW4uaXNQcm9maWxlcj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWd9O3JlYWN0SXNfcHJvZHVjdGlvbl9taW4uaXNTdHJpY3RNb2RlPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09Zn07cmVhY3RJc19wcm9kdWN0aW9uX21pbi5pc1N1c3BlbnNlPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09cH07XG4gIFx0cmVhY3RJc19wcm9kdWN0aW9uX21pbi5pc1ZhbGlkRWxlbWVudFR5cGU9ZnVuY3Rpb24oYSl7cmV0dXJuIFwic3RyaW5nXCI9PT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGF8fGE9PT1lfHxhPT09bXx8YT09PWd8fGE9PT1mfHxhPT09cHx8YT09PXF8fFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJihhLiQkdHlwZW9mPT09dHx8YS4kJHR5cGVvZj09PXJ8fGEuJCR0eXBlb2Y9PT1ofHxhLiQkdHlwZW9mPT09a3x8YS4kJHR5cGVvZj09PW58fGEuJCR0eXBlb2Y9PT13fHxhLiQkdHlwZW9mPT09eHx8YS4kJHR5cGVvZj09PXl8fGEuJCR0eXBlb2Y9PT12KX07cmVhY3RJc19wcm9kdWN0aW9uX21pbi50eXBlT2Y9ejtcbiAgXHRyZXR1cm4gcmVhY3RJc19wcm9kdWN0aW9uX21pbjtcbiAgfVxuXG4gIHZhciByZWFjdElzX2RldmVsb3BtZW50ID0ge307XG5cbiAgLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gICAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKi9cblxuICB2YXIgaGFzUmVxdWlyZWRSZWFjdElzX2RldmVsb3BtZW50O1xuXG4gIGZ1bmN0aW9uIHJlcXVpcmVSZWFjdElzX2RldmVsb3BtZW50ICgpIHtcbiAgXHRpZiAoaGFzUmVxdWlyZWRSZWFjdElzX2RldmVsb3BtZW50KSByZXR1cm4gcmVhY3RJc19kZXZlbG9wbWVudDtcbiAgXHRoYXNSZXF1aXJlZFJlYWN0SXNfZGV2ZWxvcG1lbnQgPSAxO1xuXG5cblxuICBcdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgXHQgIChmdW5jdGlvbigpIHtcblxuICBcdC8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4gIFx0Ly8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuICBcdHZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG4gIFx0dmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbiAgXHR2YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbiAgXHR2YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG4gIFx0dmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xuICBcdHZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbiAgXHR2YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG4gIFx0dmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4gIFx0Ly8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbiAgXHR2YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xuICBcdHZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xuICBcdHZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbiAgXHR2YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG4gIFx0dmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbiAgXHR2YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xuICBcdHZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG4gIFx0dmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xuICBcdHZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbiAgXHR2YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbiAgXHR2YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbiAgXHRmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBcdCAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICBcdCAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBcdCAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICBcdCAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgXHQgICAgc3dpdGNoICgkJHR5cGVvZikge1xuICBcdCAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICBcdCAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICBcdCAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gIFx0ICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICBcdCAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICBcdCAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gIFx0ICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgXHQgICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICBcdCAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gIFx0ICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgXHQgICAgICAgICAgZGVmYXVsdDpcbiAgXHQgICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gIFx0ICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgXHQgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICBcdCAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICBcdCAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gIFx0ICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgXHQgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgXHQgICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICBcdCAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgXHQgICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICBcdCAgICAgICAgICAgIH1cblxuICBcdCAgICAgICAgfVxuXG4gIFx0ICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgXHQgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgXHQgICAgfVxuICBcdCAgfVxuXG4gIFx0ICByZXR1cm4gdW5kZWZpbmVkO1xuICBcdH0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG4gIFx0dmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbiAgXHR2YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbiAgXHR2YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xuICBcdHZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xuICBcdHZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICBcdHZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbiAgXHR2YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICBcdHZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xuICBcdHZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xuICBcdHZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbiAgXHR2YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBcdHZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbiAgXHR2YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICBcdHZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuICBcdGZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICBcdCAge1xuICBcdCAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gIFx0ICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gIFx0ICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgXHQgICAgfVxuICBcdCAgfVxuXG4gIFx0ICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG4gIFx0fVxuICBcdGZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIFx0ICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xuICBcdH1cbiAgXHRmdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgXHQgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xuICBcdH1cbiAgXHRmdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgXHQgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbiAgXHR9XG4gIFx0ZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICBcdCAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgXHR9XG4gIFx0ZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICBcdCAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xuICBcdH1cbiAgXHRmdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICBcdCAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICBcdH1cbiAgXHRmdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIFx0ICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbiAgXHR9XG4gIFx0ZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICBcdCAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG4gIFx0fVxuICBcdGZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICBcdCAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbiAgXHR9XG4gIFx0ZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgXHQgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgXHR9XG4gIFx0ZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICBcdCAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuICBcdH1cbiAgXHRmdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICBcdCAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICBcdH1cblxuICBcdHJlYWN0SXNfZGV2ZWxvcG1lbnQuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuICBcdHJlYWN0SXNfZGV2ZWxvcG1lbnQuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbiAgXHRyZWFjdElzX2RldmVsb3BtZW50LkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbiAgXHRyZWFjdElzX2RldmVsb3BtZW50LkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbiAgXHRyZWFjdElzX2RldmVsb3BtZW50LkVsZW1lbnQgPSBFbGVtZW50O1xuICBcdHJlYWN0SXNfZGV2ZWxvcG1lbnQuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG4gIFx0cmVhY3RJc19kZXZlbG9wbWVudC5GcmFnbWVudCA9IEZyYWdtZW50O1xuICBcdHJlYWN0SXNfZGV2ZWxvcG1lbnQuTGF6eSA9IExhenk7XG4gIFx0cmVhY3RJc19kZXZlbG9wbWVudC5NZW1vID0gTWVtbztcbiAgXHRyZWFjdElzX2RldmVsb3BtZW50LlBvcnRhbCA9IFBvcnRhbDtcbiAgXHRyZWFjdElzX2RldmVsb3BtZW50LlByb2ZpbGVyID0gUHJvZmlsZXI7XG4gIFx0cmVhY3RJc19kZXZlbG9wbWVudC5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbiAgXHRyZWFjdElzX2RldmVsb3BtZW50LlN1c3BlbnNlID0gU3VzcGVuc2U7XG4gIFx0cmVhY3RJc19kZXZlbG9wbWVudC5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuICBcdHJlYWN0SXNfZGV2ZWxvcG1lbnQuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG4gIFx0cmVhY3RJc19kZXZlbG9wbWVudC5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuICBcdHJlYWN0SXNfZGV2ZWxvcG1lbnQuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbiAgXHRyZWFjdElzX2RldmVsb3BtZW50LmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgXHRyZWFjdElzX2RldmVsb3BtZW50LmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbiAgXHRyZWFjdElzX2RldmVsb3BtZW50LmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuICBcdHJlYWN0SXNfZGV2ZWxvcG1lbnQuaXNMYXp5ID0gaXNMYXp5O1xuICBcdHJlYWN0SXNfZGV2ZWxvcG1lbnQuaXNNZW1vID0gaXNNZW1vO1xuICBcdHJlYWN0SXNfZGV2ZWxvcG1lbnQuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbiAgXHRyZWFjdElzX2RldmVsb3BtZW50LmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuICBcdHJlYWN0SXNfZGV2ZWxvcG1lbnQuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuICBcdHJlYWN0SXNfZGV2ZWxvcG1lbnQuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG4gIFx0cmVhY3RJc19kZXZlbG9wbWVudC5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG4gIFx0cmVhY3RJc19kZXZlbG9wbWVudC50eXBlT2YgPSB0eXBlT2Y7XG4gIFx0ICB9KSgpO1xuICBcdH1cbiAgXHRyZXR1cm4gcmVhY3RJc19kZXZlbG9wbWVudDtcbiAgfVxuXG4gIHZhciBoYXNSZXF1aXJlZFJlYWN0SXM7XG5cbiAgZnVuY3Rpb24gcmVxdWlyZVJlYWN0SXMgKCkge1xuICBcdGlmIChoYXNSZXF1aXJlZFJlYWN0SXMpIHJldHVybiByZWFjdElzLmV4cG9ydHM7XG4gIFx0aGFzUmVxdWlyZWRSZWFjdElzID0gMTtcbiAgXHQoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gIFx0XHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBcdFx0ICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVSZWFjdElzX3Byb2R1Y3Rpb25fbWluKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0ICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVSZWFjdElzX2RldmVsb3BtZW50KCk7XG4gIFx0XHR9XG4gIH0gKHJlYWN0SXMpKTtcbiAgXHRyZXR1cm4gcmVhY3RJcy5leHBvcnRzO1xuICB9XG5cbiAgLypcbiAgb2JqZWN0LWFzc2lnblxuICAoYykgU2luZHJlIFNvcmh1c1xuICBAbGljZW5zZSBNSVRcbiAgKi9cblxuICB2YXIgb2JqZWN0QXNzaWduO1xuICB2YXIgaGFzUmVxdWlyZWRPYmplY3RBc3NpZ247XG5cbiAgZnVuY3Rpb24gcmVxdWlyZU9iamVjdEFzc2lnbiAoKSB7XG4gIFx0aWYgKGhhc1JlcXVpcmVkT2JqZWN0QXNzaWduKSByZXR1cm4gb2JqZWN0QXNzaWduO1xuICBcdGhhc1JlcXVpcmVkT2JqZWN0QXNzaWduID0gMTtcbiAgXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICBcdHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuICBcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIFx0dmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4gIFx0ZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG4gIFx0XHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBPYmplY3QodmFsKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG4gIFx0XHR0cnkge1xuICBcdFx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cbiAgXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuICBcdFx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gIFx0XHRcdHRlc3QxWzVdID0gJ2RlJztcbiAgXHRcdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuICBcdFx0XHR2YXIgdGVzdDIgPSB7fTtcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gIFx0XHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuICBcdFx0XHR9XG4gIFx0XHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuICBcdFx0XHR9KTtcbiAgXHRcdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuICBcdFx0XHR2YXIgdGVzdDMgPSB7fTtcbiAgXHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG4gIFx0XHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuICBcdFx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRvYmplY3RBc3NpZ24gPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgXHRcdHZhciBmcm9tO1xuICBcdFx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgXHRcdHZhciBzeW1ib2xzO1xuXG4gIFx0XHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuICBcdFx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cbiAgXHRcdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgXHRcdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gIFx0XHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgXHRcdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuICBcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuICBcdFx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuICBcdFx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0bztcbiAgXHR9O1xuICBcdHJldHVybiBvYmplY3RBc3NpZ247XG4gIH1cblxuICAvKipcbiAgICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gICAqXG4gICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gICAqL1xuXG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldF8xO1xuICB2YXIgaGFzUmVxdWlyZWRSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuICBmdW5jdGlvbiByZXF1aXJlUmVhY3RQcm9wVHlwZXNTZWNyZXQgKCkge1xuICBcdGlmIChoYXNSZXF1aXJlZFJlYWN0UHJvcFR5cGVzU2VjcmV0KSByZXR1cm4gUmVhY3RQcm9wVHlwZXNTZWNyZXRfMTtcbiAgXHRoYXNSZXF1aXJlZFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gMTtcblxuICBcdHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbiAgXHRSZWFjdFByb3BUeXBlc1NlY3JldF8xID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4gIFx0cmV0dXJuIFJlYWN0UHJvcFR5cGVzU2VjcmV0XzE7XG4gIH1cblxuICB2YXIgaGFzO1xuICB2YXIgaGFzUmVxdWlyZWRIYXM7XG5cbiAgZnVuY3Rpb24gcmVxdWlyZUhhcyAoKSB7XG4gIFx0aWYgKGhhc1JlcXVpcmVkSGFzKSByZXR1cm4gaGFzO1xuICBcdGhhc1JlcXVpcmVkSGFzID0gMTtcbiAgXHRoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4gIFx0cmV0dXJuIGhhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAgICpcbiAgICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gICAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICovXG5cbiAgdmFyIGNoZWNrUHJvcFR5cGVzXzE7XG4gIHZhciBoYXNSZXF1aXJlZENoZWNrUHJvcFR5cGVzO1xuXG4gIGZ1bmN0aW9uIHJlcXVpcmVDaGVja1Byb3BUeXBlcyAoKSB7XG4gIFx0aWYgKGhhc1JlcXVpcmVkQ2hlY2tQcm9wVHlwZXMpIHJldHVybiBjaGVja1Byb3BUeXBlc18xO1xuICBcdGhhc1JlcXVpcmVkQ2hlY2tQcm9wVHlwZXMgPSAxO1xuXG4gIFx0dmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbiAgXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBcdCAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZVJlYWN0UHJvcFR5cGVzU2VjcmV0KCk7XG4gIFx0ICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIFx0ICB2YXIgaGFzID0gcmVxdWlyZUhhcygpO1xuXG4gIFx0ICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIFx0ICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICBcdCAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIFx0ICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgXHQgICAgfVxuICBcdCAgICB0cnkge1xuICBcdCAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgXHQgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgXHQgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgXHQgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIFx0ICAgIH0gY2F0Y2ggKHgpIHsgLyoqLyB9XG4gIFx0ICB9O1xuICBcdH1cblxuICBcdC8qKlxuICBcdCAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAgXHQgKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAgXHQgKlxuICBcdCAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gIFx0ICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gIFx0ICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICBcdCAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIFx0ICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAgXHQgKiBAcHJpdmF0ZVxuICBcdCAqL1xuICBcdGZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgXHQgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFx0ICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgXHQgICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICBcdCAgICAgICAgdmFyIGVycm9yO1xuICBcdCAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgXHQgICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgXHQgICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgXHQgICAgICAgIHRyeSB7XG4gIFx0ICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICBcdCAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gIFx0ICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgXHQgICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gIFx0ICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICBcdCAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArXG4gIFx0ICAgICAgICAgICAgICAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJ1xuICBcdCAgICAgICAgICAgICk7XG4gIFx0ICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gIFx0ICAgICAgICAgICAgdGhyb3cgZXJyO1xuICBcdCAgICAgICAgICB9XG4gIFx0ICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gIFx0ICAgICAgICB9IGNhdGNoIChleCkge1xuICBcdCAgICAgICAgICBlcnJvciA9IGV4O1xuICBcdCAgICAgICAgfVxuICBcdCAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgXHQgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICBcdCAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICBcdCAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gIFx0ICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgXHQgICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gIFx0ICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gIFx0ICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gIFx0ICAgICAgICAgICk7XG4gIFx0ICAgICAgICB9XG4gIFx0ICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICBcdCAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgXHQgICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgXHQgICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICBcdCAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICBcdCAgICAgICAgICBwcmludFdhcm5pbmcoXG4gIFx0ICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICBcdCAgICAgICAgICApO1xuICBcdCAgICAgICAgfVxuICBcdCAgICAgIH1cbiAgXHQgICAgfVxuICBcdCAgfVxuICBcdH1cblxuICBcdC8qKlxuICBcdCAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAgXHQgKlxuICBcdCAqIEBwcml2YXRlXG4gIFx0ICovXG4gIFx0Y2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgXHQgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFx0ICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICBcdCAgfVxuICBcdH07XG5cbiAgXHRjaGVja1Byb3BUeXBlc18xID0gY2hlY2tQcm9wVHlwZXM7XG4gIFx0cmV0dXJuIGNoZWNrUHJvcFR5cGVzXzE7XG4gIH1cblxuICAvKipcbiAgICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gICAqXG4gICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gICAqL1xuXG4gIHZhciBmYWN0b3J5V2l0aFR5cGVDaGVja2VycztcbiAgdmFyIGhhc1JlcXVpcmVkRmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnM7XG5cbiAgZnVuY3Rpb24gcmVxdWlyZUZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzICgpIHtcbiAgXHRpZiAoaGFzUmVxdWlyZWRGYWN0b3J5V2l0aFR5cGVDaGVja2VycykgcmV0dXJuIGZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzO1xuICBcdGhhc1JlcXVpcmVkRmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMgPSAxO1xuXG4gIFx0dmFyIFJlYWN0SXMgPSByZXF1aXJlUmVhY3RJcygpO1xuICBcdHZhciBhc3NpZ24gPSByZXF1aXJlT2JqZWN0QXNzaWduKCk7XG5cbiAgXHR2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlUmVhY3RQcm9wVHlwZXNTZWNyZXQoKTtcbiAgXHR2YXIgaGFzID0gcmVxdWlyZUhhcygpO1xuICBcdHZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmVDaGVja1Byb3BUeXBlcygpO1xuXG4gIFx0dmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbiAgXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBcdCAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICBcdCAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgXHQgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICBcdCAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIFx0ICAgIH1cbiAgXHQgICAgdHJ5IHtcbiAgXHQgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gIFx0ICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gIFx0ICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gIFx0ICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBcdCAgICB9IGNhdGNoICh4KSB7fVxuICBcdCAgfTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICBcdCAgcmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICBcdCAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICBcdCAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICBcdCAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgXHQgIC8qKlxuICBcdCAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICBcdCAgICpcbiAgXHQgICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICBcdCAgICpcbiAgXHQgICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gIFx0ICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgXHQgICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgXHQgICAqICAgICAgIC4uLlxuICBcdCAgICogICAgIH1cbiAgXHQgICAqXG4gIFx0ICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgXHQgICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgXHQgICAqL1xuICBcdCAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIFx0ICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIFx0ICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICBcdCAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICBcdCAgICB9XG4gIFx0ICB9XG5cbiAgXHQgIC8qKlxuICBcdCAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgXHQgICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gIFx0ICAgKlxuICBcdCAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICBcdCAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBcdCAgICogICAgIHByb3BUeXBlczoge1xuICBcdCAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICBcdCAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgXHQgICAqXG4gIFx0ICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gIFx0ICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gIFx0ICAgKlxuICBcdCAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gIFx0ICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gIFx0ICAgKiAgICAgfSxcbiAgXHQgICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICBcdCAgICogICB9KTtcbiAgXHQgICAqXG4gIFx0ICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gIFx0ICAgKlxuICBcdCAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gIFx0ICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgXHQgICAqXG4gIFx0ICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gIFx0ICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gIFx0ICAgKlxuICBcdCAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIFx0ICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgXHQgICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICBcdCAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgXHQgICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICBcdCAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICBcdCAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgXHQgICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gIFx0ICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gIFx0ICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgXHQgICAqICAgICAgICAgICk7XG4gIFx0ICAgKiAgICAgICAgfVxuICBcdCAgICogICAgICB9XG4gIFx0ICAgKiAgICB9LFxuICBcdCAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gIFx0ICAgKiAgfSk7XG4gIFx0ICAgKlxuICBcdCAgICogQGludGVybmFsXG4gIFx0ICAgKi9cblxuICBcdCAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICBcdCAgLy8gSW1wb3J0YW50IVxuICBcdCAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICBcdCAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICBcdCAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gIFx0ICAgIGJpZ2ludDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2JpZ2ludCcpLFxuICBcdCAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICBcdCAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgXHQgICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gIFx0ICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICBcdCAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgXHQgICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgXHQgICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICBcdCAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gIFx0ICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICBcdCAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICBcdCAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICBcdCAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICBcdCAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgXHQgICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgXHQgICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICBcdCAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgXHQgICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIFx0ICB9O1xuXG4gIFx0ICAvKipcbiAgXHQgICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgXHQgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICBcdCAgICovXG4gIFx0ICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIFx0ICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIFx0ICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgXHQgICAgaWYgKHggPT09IHkpIHtcbiAgXHQgICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgXHQgICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICBcdCAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgXHQgICAgfSBlbHNlIHtcbiAgXHQgICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICBcdCAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIFx0ICAgIH1cbiAgXHQgIH1cbiAgXHQgIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIFx0ICAvKipcbiAgXHQgICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgXHQgICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gIFx0ICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gIFx0ICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gIFx0ICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gIFx0ICAgKi9cbiAgXHQgIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICBcdCAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICBcdCAgICB0aGlzLmRhdGEgPSBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGE6IHt9O1xuICBcdCAgICB0aGlzLnN0YWNrID0gJyc7XG4gIFx0ICB9XG4gIFx0ICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFx0ICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBcdCAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgXHQgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgXHQgICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgXHQgICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICBcdCAgICB9XG4gIFx0ICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICBcdCAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgXHQgICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgXHQgICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICBcdCAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgXHQgICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gIFx0ICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gIFx0ICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICBcdCAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICBcdCAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICBcdCAgICAgICAgICApO1xuICBcdCAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgXHQgICAgICAgICAgdGhyb3cgZXJyO1xuICBcdCAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICBcdCAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgXHQgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICBcdCAgICAgICAgICBpZiAoXG4gIFx0ICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICBcdCAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICBcdCAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICBcdCAgICAgICAgICApIHtcbiAgXHQgICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gIFx0ICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gIFx0ICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgXHQgICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gIFx0ICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgXHQgICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gIFx0ICAgICAgICAgICAgKTtcbiAgXHQgICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICBcdCAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gIFx0ICAgICAgICAgIH1cbiAgXHQgICAgICAgIH1cbiAgXHQgICAgICB9XG4gIFx0ICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gIFx0ICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICBcdCAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gIFx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICBcdCAgICAgICAgICB9XG4gIFx0ICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICBcdCAgICAgICAgfVxuICBcdCAgICAgICAgcmV0dXJuIG51bGw7XG4gIFx0ICAgICAgfSBlbHNlIHtcbiAgXHQgICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICBcdCAgICAgIH1cbiAgXHQgICAgfVxuXG4gIFx0ICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICBcdCAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICBcdCAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgXHQgIH1cblxuICBcdCAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gIFx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gIFx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgXHQgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBcdCAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gIFx0ICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgXHQgICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICBcdCAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICBcdCAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICBcdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICBcdCAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpLFxuICBcdCAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gIFx0ICAgICAgICApO1xuICBcdCAgICAgIH1cbiAgXHQgICAgICByZXR1cm4gbnVsbDtcbiAgXHQgICAgfVxuICBcdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICBcdCAgfVxuXG4gIFx0ICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICBcdCAgfVxuXG4gIFx0ICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gIFx0ICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICBcdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgXHQgICAgICB9XG4gIFx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgXHQgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICBcdCAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgXHQgICAgICB9XG4gIFx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgXHQgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgXHQgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gIFx0ICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgXHQgICAgICAgIH1cbiAgXHQgICAgICB9XG4gIFx0ICAgICAgcmV0dXJuIG51bGw7XG4gIFx0ICAgIH1cbiAgXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgXHQgIH1cblxuICBcdCAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICBcdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgXHQgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICBcdCAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICBcdCAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gIFx0ICAgICAgfVxuICBcdCAgICAgIHJldHVybiBudWxsO1xuICBcdCAgICB9XG4gIFx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIFx0ICB9XG5cbiAgXHQgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gIFx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICBcdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gIFx0ICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gIFx0ICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBcdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuJykpO1xuICBcdCAgICAgIH1cbiAgXHQgICAgICByZXR1cm4gbnVsbDtcbiAgXHQgICAgfVxuICBcdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICBcdCAgfVxuXG4gIFx0ICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gIFx0ICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgXHQgICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gIFx0ICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gIFx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gIFx0ICAgICAgfVxuICBcdCAgICAgIHJldHVybiBudWxsO1xuICBcdCAgICB9XG4gIFx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIFx0ICB9XG5cbiAgXHQgIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICBcdCAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gIFx0ICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgXHQgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICBcdCAgICAgICAgICBwcmludFdhcm5pbmcoXG4gIFx0ICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICBcdCAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gIFx0ICAgICAgICAgICk7XG4gIFx0ICAgICAgICB9IGVsc2Uge1xuICBcdCAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICBcdCAgICAgICAgfVxuICBcdCAgICAgIH1cbiAgXHQgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgXHQgICAgfVxuXG4gIFx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICBcdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gIFx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICBcdCAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gIFx0ICAgICAgICAgIHJldHVybiBudWxsO1xuICBcdCAgICAgICAgfVxuICBcdCAgICAgIH1cblxuICBcdCAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBcdCAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gIFx0ICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgXHQgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIFx0ICAgICAgICB9XG4gIFx0ICAgICAgICByZXR1cm4gdmFsdWU7XG4gIFx0ICAgICAgfSk7XG4gIFx0ICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gIFx0ICAgIH1cbiAgXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgXHQgIH1cblxuICBcdCAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBcdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgXHQgICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gIFx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgXHQgICAgICB9XG4gIFx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgXHQgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBcdCAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gIFx0ICAgICAgfVxuICBcdCAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgXHQgICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gIFx0ICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gIFx0ICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gIFx0ICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICBcdCAgICAgICAgICB9XG4gIFx0ICAgICAgICB9XG4gIFx0ICAgICAgfVxuICBcdCAgICAgIHJldHVybiBudWxsO1xuICBcdCAgICB9XG4gIFx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIFx0ICB9XG5cbiAgXHQgIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICBcdCAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgXHQgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gIFx0ICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gIFx0ICAgIH1cblxuICBcdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgXHQgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gIFx0ICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gIFx0ICAgICAgICBwcmludFdhcm5pbmcoXG4gIFx0ICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gIFx0ICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICBcdCAgICAgICAgKTtcbiAgXHQgICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICBcdCAgICAgIH1cbiAgXHQgICAgfVxuXG4gIFx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICBcdCAgICAgIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIFx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gIFx0ICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gIFx0ICAgICAgICB2YXIgY2hlY2tlclJlc3VsdCA9IGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gIFx0ICAgICAgICBpZiAoY2hlY2tlclJlc3VsdCA9PSBudWxsKSB7XG4gIFx0ICAgICAgICAgIHJldHVybiBudWxsO1xuICBcdCAgICAgICAgfVxuICBcdCAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQuZGF0YSAmJiBoYXMoY2hlY2tlclJlc3VsdC5kYXRhLCAnZXhwZWN0ZWRUeXBlJykpIHtcbiAgXHQgICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICBcdCAgICAgICAgfVxuICBcdCAgICAgIH1cbiAgXHQgICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgXHQgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgJyArIGV4cGVjdGVkVHlwZXNNZXNzYWdlICsgJy4nKSk7XG4gIFx0ICAgIH1cbiAgXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgXHQgIH1cblxuICBcdCAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gIFx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICBcdCAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgXHQgICAgICB9XG4gIFx0ICAgICAgcmV0dXJuIG51bGw7XG4gIFx0ICAgIH1cbiAgXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgXHQgIH1cblxuICBcdCAgZnVuY3Rpb24gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgdHlwZSkge1xuICBcdCAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gIFx0ICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgXHQgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlICsgJ2AuJ1xuICBcdCAgICApO1xuICBcdCAgfVxuXG4gIFx0ICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gIFx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgXHQgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBcdCAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgXHQgICAgICB9XG4gIFx0ICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgXHQgICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICBcdCAgICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gIFx0ICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gIFx0ICAgICAgICB9XG4gIFx0ICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gIFx0ICAgICAgICBpZiAoZXJyb3IpIHtcbiAgXHQgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICBcdCAgICAgICAgfVxuICBcdCAgICAgIH1cbiAgXHQgICAgICByZXR1cm4gbnVsbDtcbiAgXHQgICAgfVxuICBcdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICBcdCAgfVxuXG4gIFx0ICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gIFx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgXHQgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBcdCAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgXHQgICAgICB9XG4gIFx0ICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb20gcHJvcHMuXG4gIFx0ICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gIFx0ICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgXHQgICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICBcdCAgICAgICAgaWYgKGhhcyhzaGFwZVR5cGVzLCBrZXkpICYmIHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gIFx0ICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gIFx0ICAgICAgICB9XG4gIFx0ICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgXHQgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICBcdCAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgXHQgICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICBcdCAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gIFx0ICAgICAgICAgICk7XG4gIFx0ICAgICAgICB9XG4gIFx0ICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gIFx0ICAgICAgICBpZiAoZXJyb3IpIHtcbiAgXHQgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICBcdCAgICAgICAgfVxuICBcdCAgICAgIH1cbiAgXHQgICAgICByZXR1cm4gbnVsbDtcbiAgXHQgICAgfVxuXG4gIFx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIFx0ICB9XG5cbiAgXHQgIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgXHQgICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gIFx0ICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgXHQgICAgICBjYXNlICdzdHJpbmcnOlxuICBcdCAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gIFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgXHQgICAgICBjYXNlICdib29sZWFuJzpcbiAgXHQgICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICBcdCAgICAgIGNhc2UgJ29iamVjdCc6XG4gIFx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gIFx0ICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgXHQgICAgICAgIH1cbiAgXHQgICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICBcdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgXHQgICAgICAgIH1cblxuICBcdCAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gIFx0ICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICBcdCAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgXHQgICAgICAgICAgdmFyIHN0ZXA7XG4gIFx0ICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICBcdCAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgXHQgICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gIFx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgXHQgICAgICAgICAgICAgIH1cbiAgXHQgICAgICAgICAgICB9XG4gIFx0ICAgICAgICAgIH0gZWxzZSB7XG4gIFx0ICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gIFx0ICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICBcdCAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgXHQgICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICBcdCAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgXHQgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gIFx0ICAgICAgICAgICAgICAgIH1cbiAgXHQgICAgICAgICAgICAgIH1cbiAgXHQgICAgICAgICAgICB9XG4gIFx0ICAgICAgICAgIH1cbiAgXHQgICAgICAgIH0gZWxzZSB7XG4gIFx0ICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgXHQgICAgICAgIH1cblxuICBcdCAgICAgICAgcmV0dXJuIHRydWU7XG4gIFx0ICAgICAgZGVmYXVsdDpcbiAgXHQgICAgICAgIHJldHVybiBmYWxzZTtcbiAgXHQgICAgfVxuICBcdCAgfVxuXG4gIFx0ICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gIFx0ICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gIFx0ICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgXHQgICAgICByZXR1cm4gdHJ1ZTtcbiAgXHQgICAgfVxuXG4gIFx0ICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gIFx0ICAgIGlmICghcHJvcFZhbHVlKSB7XG4gIFx0ICAgICAgcmV0dXJuIGZhbHNlO1xuICBcdCAgICB9XG5cbiAgXHQgICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgXHQgICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICBcdCAgICAgIHJldHVybiB0cnVlO1xuICBcdCAgICB9XG5cbiAgXHQgICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICBcdCAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgXHQgICAgICByZXR1cm4gdHJ1ZTtcbiAgXHQgICAgfVxuXG4gIFx0ICAgIHJldHVybiBmYWxzZTtcbiAgXHQgIH1cblxuICBcdCAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBcdCAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gIFx0ICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gIFx0ICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgXHQgICAgICByZXR1cm4gJ2FycmF5JztcbiAgXHQgICAgfVxuICBcdCAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gIFx0ICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICBcdCAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICBcdCAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICBcdCAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgXHQgICAgfVxuICBcdCAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgXHQgICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gIFx0ICAgIH1cbiAgXHQgICAgcmV0dXJuIHByb3BUeXBlO1xuICBcdCAgfVxuXG4gIFx0ICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIFx0ICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgXHQgIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICBcdCAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gIFx0ICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICBcdCAgICB9XG4gIFx0ICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gIFx0ICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgXHQgICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICBcdCAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgXHQgICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICBcdCAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICBcdCAgICAgIH1cbiAgXHQgICAgfVxuICBcdCAgICByZXR1cm4gcHJvcFR5cGU7XG4gIFx0ICB9XG5cbiAgXHQgIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgXHQgIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIFx0ICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgXHQgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gIFx0ICAgIHN3aXRjaCAodHlwZSkge1xuICBcdCAgICAgIGNhc2UgJ2FycmF5JzpcbiAgXHQgICAgICBjYXNlICdvYmplY3QnOlxuICBcdCAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgXHQgICAgICBjYXNlICdib29sZWFuJzpcbiAgXHQgICAgICBjYXNlICdkYXRlJzpcbiAgXHQgICAgICBjYXNlICdyZWdleHAnOlxuICBcdCAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICBcdCAgICAgIGRlZmF1bHQ6XG4gIFx0ICAgICAgICByZXR1cm4gdHlwZTtcbiAgXHQgICAgfVxuICBcdCAgfVxuXG4gIFx0ICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBcdCAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICBcdCAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgXHQgICAgICByZXR1cm4gQU5PTllNT1VTO1xuICBcdCAgICB9XG4gIFx0ICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgXHQgIH1cblxuICBcdCAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgXHQgIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFx0ICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICBcdCAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xuICBcdH07XG4gIFx0cmV0dXJuIGZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKi9cblxuICB2YXIgZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zO1xuICB2YXIgaGFzUmVxdWlyZWRGYWN0b3J5V2l0aFRocm93aW5nU2hpbXM7XG5cbiAgZnVuY3Rpb24gcmVxdWlyZUZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcyAoKSB7XG4gIFx0aWYgKGhhc1JlcXVpcmVkRmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zKSByZXR1cm4gZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zO1xuICBcdGhhc1JlcXVpcmVkRmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zID0gMTtcblxuICBcdHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmVSZWFjdFByb3BUeXBlc1NlY3JldCgpO1xuXG4gIFx0ZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG4gIFx0ZnVuY3Rpb24gZW1wdHlGdW5jdGlvbldpdGhSZXNldCgpIHt9XG4gIFx0ZW1wdHlGdW5jdGlvbldpdGhSZXNldC5yZXNldFdhcm5pbmdDYWNoZSA9IGVtcHR5RnVuY3Rpb247XG5cbiAgXHRmYWN0b3J5V2l0aFRocm93aW5nU2hpbXMgPSBmdW5jdGlvbigpIHtcbiAgXHQgIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgXHQgICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgXHQgICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gIFx0ICAgICAgcmV0dXJuO1xuICBcdCAgICB9XG4gIFx0ICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gIFx0ICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICBcdCAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgXHQgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgXHQgICAgKTtcbiAgXHQgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gIFx0ICAgIHRocm93IGVycjtcbiAgXHQgIH1cdCAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgXHQgIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gIFx0ICAgIHJldHVybiBzaGltO1xuICBcdCAgfVx0ICAvLyBJbXBvcnRhbnQhXG4gIFx0ICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgXHQgIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgXHQgICAgYXJyYXk6IHNoaW0sXG4gIFx0ICAgIGJpZ2ludDogc2hpbSxcbiAgXHQgICAgYm9vbDogc2hpbSxcbiAgXHQgICAgZnVuYzogc2hpbSxcbiAgXHQgICAgbnVtYmVyOiBzaGltLFxuICBcdCAgICBvYmplY3Q6IHNoaW0sXG4gIFx0ICAgIHN0cmluZzogc2hpbSxcbiAgXHQgICAgc3ltYm9sOiBzaGltLFxuXG4gIFx0ICAgIGFueTogc2hpbSxcbiAgXHQgICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgXHQgICAgZWxlbWVudDogc2hpbSxcbiAgXHQgICAgZWxlbWVudFR5cGU6IHNoaW0sXG4gIFx0ICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gIFx0ICAgIG5vZGU6IHNoaW0sXG4gIFx0ICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICBcdCAgICBvbmVPZjogZ2V0U2hpbSxcbiAgXHQgICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICBcdCAgICBzaGFwZTogZ2V0U2hpbSxcbiAgXHQgICAgZXhhY3Q6IGdldFNoaW0sXG5cbiAgXHQgICAgY2hlY2tQcm9wVHlwZXM6IGVtcHR5RnVuY3Rpb25XaXRoUmVzZXQsXG4gIFx0ICAgIHJlc2V0V2FybmluZ0NhY2hlOiBlbXB0eUZ1bmN0aW9uXG4gIFx0ICB9O1xuXG4gIFx0ICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICBcdCAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xuICBcdH07XG4gIFx0cmV0dXJuIGZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAgICpcbiAgICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gICAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICovXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgUmVhY3RJcyA9IHJlcXVpcmVSZWFjdElzKCk7XG5cbiAgICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gICAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICAgIHByb3BUeXBlcy5leHBvcnRzID0gcmVxdWlyZUZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzKCkoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gICAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICAgIHByb3BUeXBlcy5leHBvcnRzID0gcmVxdWlyZUZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcygpKCk7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cblxuICAvKipcbiAgICogdXNlRXZlbnRMaXN0ZW5lclxuICAgKiBIb29rIGZvciBoYW5kbGluZyBFdmVudExpc3RlbmVyc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9IHdpZHRoLCBoZWlnaHRcbiAgICovXG5cbiAgZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGVsZW1lbnQgPSB3aW5kb3cpIHtcbiAgICAvLyBDcmVhdGUgYSByZWYgdGhhdCBzdG9yZXMgaGFuZGxlclxuICAgIGNvbnN0IHNhdmVkSGFuZGxlciA9IFJlYWN0LnVzZVJlZigpOyAvLyBVcGRhdGUgcmVmLmN1cnJlbnQgdmFsdWUgaWYgaGFuZGxlciBjaGFuZ2VzLlxuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHNhdmVkSGFuZGxlci5jdXJyZW50ID0gaGFuZGxlcjtcbiAgICB9LCBbaGFuZGxlcl0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAvLyBNYWtlIHN1cmUgZWxlbWVudCBzdXBwb3J0cyBhZGRFdmVudExpc3RlbmVyXG4gICAgICBjb25zdCBpc1N1cHBvcnRlZCA9IGVsZW1lbnQgJiYgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyO1xuICAgICAgaWYgKCFpc1N1cHBvcnRlZCkgcmV0dXJuOyAvLyBDcmVhdGUgZXZlbnQgbGlzdGVuZXIgdGhhdCBjYWxscyBoYW5kbGVyIGZ1bmN0aW9uIHN0b3JlZCBpbiByZWZcblxuICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IGV2ZW50ID0+IHNhdmVkSGFuZGxlci5jdXJyZW50KGV2ZW50KTsgLy8gQWRkIGV2ZW50IGxpc3RlbmVyXG5cblxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcik7IC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lciBvbiBjbGVhbnVwXG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgfTtcbiAgICB9LCBbZXZlbnROYW1lLCBlbGVtZW50XSAvLyBSZS1ydW4gaWYgZXZlbnROYW1lIG9yIGVsZW1lbnQgY2hhbmdlc1xuICAgICk7XG4gIH1cblxuICBjb25zdCBJc0RldmljZSA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBsZXQgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIHJldHVybiB7XG4gICAgICBpbmZvOiB1YSxcblxuICAgICAgQW5kcm9pZCgpIHtcbiAgICAgICAgcmV0dXJuIHVhLm1hdGNoKC9BbmRyb2lkL2kpO1xuICAgICAgfSxcblxuICAgICAgQmxhY2tCZXJyeSgpIHtcbiAgICAgICAgcmV0dXJuIHVhLm1hdGNoKC9CbGFja0JlcnJ5L2kpO1xuICAgICAgfSxcblxuICAgICAgSUVNb2JpbGUoKSB7XG4gICAgICAgIHJldHVybiB1YS5tYXRjaCgvSUVNb2JpbGUvaSk7XG4gICAgICB9LFxuXG4gICAgICBpT1MoKSB7XG4gICAgICAgIHJldHVybiB1YS5tYXRjaCgvaVBob25lfGlQYWR8aVBvZC9pKTtcbiAgICAgIH0sXG5cbiAgICAgIGlQYWQoKSB7XG4gICAgICAgIHJldHVybiB1YS5tYXRjaCgvTWFjLykgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDI7XG4gICAgICB9LFxuXG4gICAgICBPcGVyYU1pbmkoKSB7XG4gICAgICAgIHJldHVybiB1YS5tYXRjaCgvT3BlcmEgTWluaS9pKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQW55IERldmljZVxuICAgICAgICovXG4gICAgICBhbnkoKSB7XG4gICAgICAgIHJldHVybiBJc0RldmljZS5BbmRyb2lkKCkgfHwgSXNEZXZpY2UuQmxhY2tCZXJyeSgpIHx8IElzRGV2aWNlLmlPUygpIHx8IElzRGV2aWNlLmlQYWQoKSB8fCBJc0RldmljZS5PcGVyYU1pbmkoKSB8fCBJc0RldmljZS5JRU1vYmlsZSgpO1xuICAgICAgfVxuXG4gICAgfTtcbiAgfSkoKTsgLy8gRXhwb3J0XG5cbiAgLyoqXG4gICAqIEN1cnNvciBDb3JlXG4gICAqIFJlcGxhY2VzIHRoZSBuYXRpdmUgY3Vyc29yIHdpdGggYSBjdXN0b20gYW5pbWF0ZWQgY3Vyc29yLCBjb25zaXN0aW5nXG4gICAqIG9mIGFuIGlubmVyIGFuZCBvdXRlciBkb3QgdGhhdCBzY2FsZSBpbnZlcnNlbHkgYmFzZWQgb24gaG92ZXIgb3IgY2xpY2suXG4gICAqXG4gICAqIEBhdXRob3IgU3RlcGhlbiBTY2FmZiAoZ2l0aHViLmNvbS9zdGVwaGVuc2NhZmYpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIHJnYiBjb2xvciB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJBbHBoYSAtIGxldmVsIG9mIGFscGhhIHRyYW5zcGFyZW5jeSBmb3IgY29sb3JcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlubmVyU2l6ZSAtIGlubmVyIGN1cnNvciBzaXplIGluIHB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbm5lclNjYWxlIC0gaW5uZXIgY3Vyc29yIHNjYWxlIGFtb3VudFxuICAgKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJTaXplIC0gb3V0ZXIgY3Vyc29yIHNpemUgaW4gcHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IG91dGVyU2NhbGUgLSBvdXRlciBjdXJzb3Igc2NhbGUgYW1vdW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvdXRlclN0eWxlIC0gc3R5bGUgb2JqZWN0IGZvciBvdXRlciBjdXJzb3JcbiAgICogQHBhcmFtIHtvYmplY3R9IGlubmVyU3R5bGUgLSBzdHlsZSBvYmplY3QgZm9yIGlubmVyIGN1cnNvclxuICAgKiBAcGFyYW0ge2FycmF5fSAgY2xpY2thYmxlcyAtIGFycmF5IG9mIGNsaWNrYWJsZSBzZWxlY3RvcnNcbiAgICpcbiAgICovXG5cbiAgZnVuY3Rpb24gQ3Vyc29yQ29yZSh7XG4gICAgb3V0ZXJTdHlsZSxcbiAgICBpbm5lclN0eWxlLFxuICAgIGNvbG9yID0gJzIyMCwgOTAsIDkwJyxcbiAgICBvdXRlckFscGhhID0gMC4zLFxuICAgIGlubmVyU2l6ZSA9IDgsXG4gICAgb3V0ZXJTaXplID0gOCxcbiAgICBvdXRlclNjYWxlID0gNixcbiAgICBpbm5lclNjYWxlID0gMC42LFxuICAgIHRyYWlsaW5nU3BlZWQgPSA4LFxuICAgIGNsaWNrYWJsZXMgPSBbJ2EnLCAnaW5wdXRbdHlwZT1cInRleHRcIl0nLCAnaW5wdXRbdHlwZT1cImVtYWlsXCJdJywgJ2lucHV0W3R5cGU9XCJudW1iZXJcIl0nLCAnaW5wdXRbdHlwZT1cInN1Ym1pdFwiXScsICdpbnB1dFt0eXBlPVwiaW1hZ2VcIl0nLCAnbGFiZWxbZm9yXScsICdzZWxlY3QnLCAndGV4dGFyZWEnLCAnYnV0dG9uJywgJy5saW5rJ11cbiAgfSkge1xuICAgIGNvbnN0IGN1cnNvck91dGVyUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgY3Vyc29ySW5uZXJSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBjb25zdCByZXF1ZXN0UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgcHJldmlvdXNUaW1lUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgW2Nvb3Jkcywgc2V0Q29vcmRzXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSk7XG4gICAgY29uc3QgW2lzVmlzaWJsZSwgc2V0SXNWaXNpYmxlXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbaXNBY3RpdmUsIHNldElzQWN0aXZlXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbaXNBY3RpdmVDbGlja2FibGUsIHNldElzQWN0aXZlQ2xpY2thYmxlXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBsZXQgZW5kWCA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICBsZXQgZW5kWSA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICAvKipcbiAgICAgKiBQcmltYXJ5IE1vdXNlIG1vdmUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50WCAtIE1vdXNlRXZlbnQuY2xpZW50eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRZIC0gTW91c2VFdmVudC5jbGllbnR5XG4gICAgICovXG5cbiAgICBjb25zdCBvbk1vdXNlTW92ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCh7XG4gICAgICBjbGllbnRYLFxuICAgICAgY2xpZW50WVxuICAgIH0pID0+IHtcbiAgICAgIHNldENvb3Jkcyh7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH0pO1xuICAgICAgY3Vyc29ySW5uZXJSZWYuY3VycmVudC5zdHlsZS50b3AgPSBgJHtjbGllbnRZfXB4YDtcbiAgICAgIGN1cnNvcklubmVyUmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IGAke2NsaWVudFh9cHhgO1xuICAgICAgZW5kWC5jdXJyZW50ID0gY2xpZW50WDtcbiAgICAgIGVuZFkuY3VycmVudCA9IGNsaWVudFk7XG4gICAgfSwgW10pOyAvLyBPdXRlciBDdXJzb3IgQW5pbWF0aW9uIERlbGF5XG5cbiAgICBjb25zdCBhbmltYXRlT3V0ZXJDdXJzb3IgPSBSZWFjdC51c2VDYWxsYmFjayh0aW1lID0+IHtcbiAgICAgIGlmIChwcmV2aW91c1RpbWVSZWYuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvb3Jkcy54ICs9IChlbmRYLmN1cnJlbnQgLSBjb29yZHMueCkgLyB0cmFpbGluZ1NwZWVkO1xuICAgICAgICBjb29yZHMueSArPSAoZW5kWS5jdXJyZW50IC0gY29vcmRzLnkpIC8gdHJhaWxpbmdTcGVlZDtcbiAgICAgICAgY3Vyc29yT3V0ZXJSZWYuY3VycmVudC5zdHlsZS50b3AgPSBgJHtjb29yZHMueX1weGA7XG4gICAgICAgIGN1cnNvck91dGVyUmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IGAke2Nvb3Jkcy54fXB4YDtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNUaW1lUmVmLmN1cnJlbnQgPSB0aW1lO1xuICAgICAgcmVxdWVzdFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGVPdXRlckN1cnNvcik7XG4gICAgfSwgW3JlcXVlc3RSZWZdIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICApOyAvLyBSQUYgZm9yIGFuaW1hdGVPdXRlckN1cnNvclxuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHJlcXVlc3RSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlT3V0ZXJDdXJzb3IpO1xuICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RSZWYuY3VycmVudCk7XG4gICAgfSwgW2FuaW1hdGVPdXRlckN1cnNvcl0pOyAvLyBNb3VzZSBFdmVudHMgU3RhdGUgdXBkYXRlc1xuXG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBzZXRJc0FjdGl2ZSh0cnVlKSwgW10pO1xuICAgIGNvbnN0IG9uTW91c2VVcCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHNldElzQWN0aXZlKGZhbHNlKSwgW10pO1xuICAgIGNvbnN0IG9uTW91c2VFbnRlclZpZXdwb3J0ID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4gc2V0SXNWaXNpYmxlKHRydWUpLCBbXSk7XG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlVmlld3BvcnQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBzZXRJc1Zpc2libGUoZmFsc2UpLCBbXSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBvbk1vdXNlRW50ZXJWaWV3cG9ydCk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBvbk1vdXNlTGVhdmVWaWV3cG9ydCk7IC8vIEN1cnNvcnMgSG92ZXIvQWN0aXZlIFN0YXRlXG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgIGN1cnNvcklubmVyUmVmLmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgtNTAlLCAtNTAlKSBzY2FsZSgke2lubmVyU2NhbGV9KWA7XG4gICAgICAgIGN1cnNvck91dGVyUmVmLmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgtNTAlLCAtNTAlKSBzY2FsZSgke291dGVyU2NhbGV9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3JJbm5lclJlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSkgc2NhbGUoMSknO1xuICAgICAgICBjdXJzb3JPdXRlclJlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSkgc2NhbGUoMSknO1xuICAgICAgfVxuICAgIH0sIFtpbm5lclNjYWxlLCBvdXRlclNjYWxlLCBpc0FjdGl2ZV0pOyAvLyBDdXJzb3JzIENsaWNrIFN0YXRlc1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChpc0FjdGl2ZUNsaWNrYWJsZSkge1xuICAgICAgICBjdXJzb3JJbm5lclJlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoLTUwJSwgLTUwJSkgc2NhbGUoJHtpbm5lclNjYWxlICogMS4yfSlgO1xuICAgICAgICBjdXJzb3JPdXRlclJlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoLTUwJSwgLTUwJSkgc2NhbGUoJHtvdXRlclNjYWxlICogMS40fSlgO1xuICAgICAgfVxuICAgIH0sIFtpbm5lclNjYWxlLCBvdXRlclNjYWxlLCBpc0FjdGl2ZUNsaWNrYWJsZV0pOyAvLyBDdXJzb3IgVmlzaWJpbGl0eSBTdGF0ZVxuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgY3Vyc29ySW5uZXJSZWYuY3VycmVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgY3Vyc29yT3V0ZXJSZWYuY3VycmVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvcklubmVyUmVmLmN1cnJlbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIGN1cnNvck91dGVyUmVmLmN1cnJlbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB9XG4gICAgfSwgW2lzVmlzaWJsZV0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBjbGlja2FibGVFbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGNsaWNrYWJsZXMuam9pbignLCcpKTtcbiAgICAgIGNsaWNrYWJsZUVscy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgZWwuc3R5bGUuY3Vyc29yID0gJ25vbmUnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCAoKSA9PiB7XG4gICAgICAgICAgc2V0SXNBY3RpdmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICBzZXRJc0FjdGl2ZSh0cnVlKTtcbiAgICAgICAgICBzZXRJc0FjdGl2ZUNsaWNrYWJsZShmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoKSA9PiB7XG4gICAgICAgICAgc2V0SXNBY3RpdmVDbGlja2FibGUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4ge1xuICAgICAgICAgIHNldElzQWN0aXZlKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgc2V0SXNBY3RpdmUoZmFsc2UpO1xuICAgICAgICAgIHNldElzQWN0aXZlQ2xpY2thYmxlKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsaWNrYWJsZUVscy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCAoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0FjdGl2ZSh0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHNldElzQWN0aXZlKHRydWUpO1xuICAgICAgICAgICAgc2V0SXNBY3RpdmVDbGlja2FibGUoZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsICgpID0+IHtcbiAgICAgICAgICAgIHNldElzQWN0aXZlQ2xpY2thYmxlKHRydWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0FjdGl2ZSh0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgIHNldElzQWN0aXZlKGZhbHNlKTtcbiAgICAgICAgICAgIHNldElzQWN0aXZlQ2xpY2thYmxlKGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sIFtpc0FjdGl2ZSwgY2xpY2thYmxlc10pOyAvLyBDdXJzb3IgU3R5bGVzXG5cbiAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICBjdXJzb3JJbm5lcjoge1xuICAgICAgICB6SW5kZXg6IDk5OSxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICAgIHdpZHRoOiBpbm5lclNpemUsXG4gICAgICAgIGhlaWdodDogaW5uZXJTaXplLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYHJnYmEoJHtjb2xvcn0sIDEpYCxcbiAgICAgICAgLi4uKGlubmVyU3R5bGUgJiYgaW5uZXJTdHlsZSksXG4gICAgICAgIHRyYW5zaXRpb246ICdvcGFjaXR5IDAuMTVzIGVhc2UtaW4tb3V0LCB0cmFuc2Zvcm0gMC4yNXMgZWFzZS1pbi1vdXQnXG4gICAgICB9LFxuICAgICAgY3Vyc29yT3V0ZXI6IHtcbiAgICAgICAgekluZGV4OiA5OTksXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgIHdpZHRoOiBvdXRlclNpemUsXG4gICAgICAgIGhlaWdodDogb3V0ZXJTaXplLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGByZ2JhKCR7Y29sb3J9LCAke291dGVyQWxwaGF9KWAsXG4gICAgICAgIHRyYW5zaXRpb246ICdvcGFjaXR5IDAuMTVzIGVhc2UtaW4tb3V0LCB0cmFuc2Zvcm0gMC4xNXMgZWFzZS1pbi1vdXQnLFxuICAgICAgICB3aWxsQ2hhbmdlOiAndHJhbnNmb3JtJyxcbiAgICAgICAgLi4uKG91dGVyU3R5bGUgJiYgb3V0ZXJTdHlsZSlcbiAgICAgIH1cbiAgICB9OyAvLyBIaWRlIC8gU2hvdyBnbG9iYWwgY3Vyc29yXG5cbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdub25lJztcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogY3Vyc29yT3V0ZXJSZWYsXG4gICAgICBzdHlsZTogc3R5bGVzLmN1cnNvck91dGVyXG4gICAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICByZWY6IGN1cnNvcklubmVyUmVmLFxuICAgICAgc3R5bGU6IHN0eWxlcy5jdXJzb3JJbm5lclxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogQW5pbWF0ZWRDdXJzb3JcbiAgICogQ2FsbHMgYW5kIHBhc3NlcyBwcm9wcyB0byBDdXJzb3JDb3JlIGlmIG5vdCBhIHRvdWNoL21vYmlsZSBkZXZpY2UuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gQW5pbWF0ZWRDdXJzb3Ioe1xuICAgIG91dGVyU3R5bGUsXG4gICAgaW5uZXJTdHlsZSxcbiAgICBjb2xvcixcbiAgICBvdXRlckFscGhhLFxuICAgIGlubmVyU2l6ZSxcbiAgICBpbm5lclNjYWxlLFxuICAgIG91dGVyU2l6ZSxcbiAgICBvdXRlclNjYWxlLFxuICAgIHRyYWlsaW5nU3BlZWQsXG4gICAgY2xpY2thYmxlc1xuICB9KSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIElzRGV2aWNlLmFueSgpKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5GcmFnbWVudCwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChDdXJzb3JDb3JlLCB7XG4gICAgICBvdXRlclN0eWxlOiBvdXRlclN0eWxlLFxuICAgICAgaW5uZXJTdHlsZTogaW5uZXJTdHlsZSxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIG91dGVyQWxwaGE6IG91dGVyQWxwaGEsXG4gICAgICBpbm5lclNpemU6IGlubmVyU2l6ZSxcbiAgICAgIGlubmVyU2NhbGU6IGlubmVyU2NhbGUsXG4gICAgICBvdXRlclNpemU6IG91dGVyU2l6ZSxcbiAgICAgIG91dGVyU2NhbGU6IG91dGVyU2NhbGUsXG4gICAgICB0cmFpbGluZ1NwZWVkOiB0cmFpbGluZ1NwZWVkLFxuICAgICAgY2xpY2thYmxlczogY2xpY2thYmxlc1xuICAgIH0pO1xuICB9XG5cbiAgQW5pbWF0ZWRDdXJzb3IucHJvcFR5cGVzID0ge1xuICAgIGNvbG9yOiBwcm9wVHlwZXMuZXhwb3J0cy5zdHJpbmcsXG4gICAgb3V0ZXJBbHBoYTogcHJvcFR5cGVzLmV4cG9ydHMubnVtYmVyLFxuICAgIGlubmVyU2l6ZTogcHJvcFR5cGVzLmV4cG9ydHMubnVtYmVyLFxuICAgIG91dGVyU2l6ZTogcHJvcFR5cGVzLmV4cG9ydHMubnVtYmVyLFxuICAgIG91dGVyU2NhbGU6IHByb3BUeXBlcy5leHBvcnRzLm51bWJlcixcbiAgICBpbm5lclNjYWxlOiBwcm9wVHlwZXMuZXhwb3J0cy5udW1iZXIsXG4gICAgb3V0ZXJTdHlsZTogcHJvcFR5cGVzLmV4cG9ydHMub2JqZWN0LFxuICAgIGlubmVyU3R5bGU6IHByb3BUeXBlcy5leHBvcnRzLm9iamVjdCxcbiAgICB0cmFpbGluZ1NwZWVkOiBwcm9wVHlwZXMuZXhwb3J0cy5udW1iZXIsXG4gICAgY2xpY2thYmxlczogcHJvcFR5cGVzLmV4cG9ydHMuYXJyYXlcbiAgfTtcblxuICByZXR1cm4gQW5pbWF0ZWRDdXJzb3I7XG5cbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-animated-cursor/dist/index.umd.js\n");

/***/ })

}]);